# JavaScript Applet API Integration Guide

This guide explains how JavaScript applets generated by the HtmlGeneration feature can call your interface APIs to load and save data.

## Overview

The HtmlGeneration feature now includes automatic API integration capabilities that allow generated JavaScript applets to:

1. **Load data** from your content APIs
2. **Save new data** to the system
3. **Update existing data** 
4. **Delete data** when authorized
5. **Search and filter** content

## Security Model

### Tenant-Scoped Architecture
- **Content Definitions**: Owned by tenants - define the schema and structure
- **Data Objects**: Owned by users - actual content instances
- **Access Control**: Role-based with tenant permissions

### Authentication
- All API calls are automatically authenticated using the user's session
- No API keys or additional authentication required in applet code
- Session-based security ensures user can only access authorized data

## Available APIs

### 1. Applet API (Recommended)
**Base URL**: `/api/applet-api`

This is a specialized endpoint designed for sandbox environments with enhanced security:

#### List Content
```javascript
const response = await fetch('/api/applet-api?operation=list&type=notes&tenantId=your-tenant-id');
const data = await response.json();
// Returns: { success: true, items: [...], total: number }
```

#### Get Specific Content
```javascript
const response = await fetch('/api/applet-api?operation=get&type=notes&contentId=item-id&tenantId=your-tenant-id');
const data = await response.json();
// Returns: { success: true, item: {...} }
```

#### Create Content
```javascript
const response = await fetch('/api/applet-api?operation=create&type=notes&tenantId=your-tenant-id', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    content: {
      title: 'My Note',
      content: 'Note content here',
      tags: ['important']
    }
  })
});
```

#### Update Content
```javascript
const response = await fetch('/api/applet-api?operation=update&type=notes&contentId=item-id&tenantId=your-tenant-id', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    content: {
      title: 'Updated Note',
      content: 'Updated content'
    }
  })
});
```

#### Delete Content
```javascript
const response = await fetch('/api/applet-api?operation=delete&type=notes&contentId=item-id&tenantId=your-tenant-id', {
  method: 'DELETE'
});
```

### 2. Direct Content APIs
**Base URLs**: 
- `/api/contentList` (GET only)
- `/api/contentDetail` (GET, POST, PUT, DELETE)

These are the underlying APIs with more direct access but require proper parameter formatting.

## NiaAPI Helper Class

Generated applets automatically include a `NiaAPI` helper class that simplifies API calls:

```javascript
// Initialize API client (automatically included in generated applets)
const api = new NiaAPI('your-tenant-id', 'assistant-name');

// List all notes
const notes = await api.listContent('notes');

// Get specific note
const note = await api.getContent('notes', 'note-id');

// Create new note
const newNote = await api.createContent('notes', {
  title: 'My New Note',
  content: 'This is my note content',
  tags: ['work', 'important']
});

// Update existing note
const updated = await api.updateContent('notes', 'note-id', {
  title: 'Updated Title',
  content: 'Updated content'
});

// Delete note
await api.deleteContent('notes', 'note-id');

// Search with filters
const workNotes = await api.listContent('notes', {
  tags: { contains: 'work' }
});
```

## Content Type Schemas

### Automatic Schema Detection
The AI generation process automatically detects available content types for your tenant and includes their schemas in the generated code.

### Common Content Types

#### Notes
```json
{
  "type": "object",
  "properties": {
    "title": { "type": "string", "description": "Note title" },
    "content": { "type": "string", "description": "Note content" },
    "tags": { "type": "array", "items": { "type": "string" } },
    "createdAt": { "type": "string", "format": "date-time" },
    "updatedAt": { "type": "string", "format": "date-time" }
  },
  "required": ["title", "content"]
}
```

#### Tasks
```json
{
  "type": "object",
  "properties": {
    "title": { "type": "string", "description": "Task title" },
    "description": { "type": "string", "description": "Task description" },
    "status": { "type": "string", "enum": ["pending", "in_progress", "completed"] },
    "priority": { "type": "string", "enum": ["low", "medium", "high"] },
    "dueDate": { "type": "string", "format": "date" },
    "tags": { "type": "array", "items": { "type": "string" } },
    "createdAt": { "type": "string", "format": "date-time" }
  },
  "required": ["title", "status"]
}
```

## Example Integration Patterns

### 1. Simple Data Display App
```javascript
// Load and display data
async function loadNotes() {
  try {
    const notes = await api.listContent('notes');
    const container = document.getElementById('notes-container');
    
    container.innerHTML = notes.map(note => `
      <div class="note-card" data-id="${note.page_id}">
        <h3>${note.title}</h3>
        <p>${note.content}</p>
        <small>Tags: ${note.tags?.join(', ') || 'None'}</small>
      </div>
    `).join('');
  } catch (error) {
    const logger = window.logger ?? { error: () => {}, info: () => {} };
    logger.error('Failed to load notes', { error });
    showError('Failed to load notes');
  }
}
```

### 2. Interactive Todo App
```javascript
// Create new task
async function createTask(title, description) {
  try {
    const task = await api.createContent('tasks', {
      title,
      description,
      status: 'pending',
      priority: 'medium',
      createdAt: new Date().toISOString()
    });
    
    renderTask(task);
    showSuccess('Task created successfully');
  } catch (error) {
    showError('Failed to create task');
  }
}

// Update task status
async function toggleTaskStatus(taskId, currentStatus) {
  const newStatus = currentStatus === 'completed' ? 'pending' : 'completed';
  
  try {
    await api.updateContent('tasks', taskId, { 
      status: newStatus,
      updatedAt: new Date().toISOString()
    });
    
    updateTaskUI(taskId, newStatus);
  } catch (error) {
    showError('Failed to update task');
  }
}
```

### 3. Search and Filter
```javascript
// Search notes by tags
async function searchNotesByTag(tag) {
  try {
    const notes = await api.listContent('notes', {
      tags: { contains: tag }
    });
    
    displaySearchResults(notes);
  } catch (error) {
    showError('Search failed');
  }
}

// Filter tasks by status
async function filterTasksByStatus(status) {
  try {
    const tasks = await api.listContent('tasks', {
      status: { eq: status }
    });
    
    displayTasks(tasks);
  } catch (error) {
    showError('Filter failed');
  }
}
```

## Error Handling Best Practices

### 1. Always Use Try-Catch
```javascript
async function safeApiCall() {
  try {
    const result = await api.listContent('notes');
    return result;
  } catch (error) {
    const logger = window.logger ?? { error: () => {}, info: () => {} };
    logger.error('API call failed', { error });
    showUserFriendlyError();
    return [];
  }
}
```

### 2. Provide User Feedback
```javascript
function showError(message) {
  const errorDiv = document.getElementById('error-message');
  errorDiv.textContent = message;
  errorDiv.style.display = 'block';
  setTimeout(() => errorDiv.style.display = 'none', 5000);
}

function showSuccess(message) {
  const successDiv = document.getElementById('success-message');
  successDiv.textContent = message;
  successDiv.style.display = 'block';
  setTimeout(() => successDiv.style.display = 'none', 3000);
}
```

### 3. Handle Loading States
```javascript
async function loadDataWithFeedback() {
  const loadingEl = document.getElementById('loading');
  const contentEl = document.getElementById('content');
  
  loadingEl.style.display = 'block';
  contentEl.style.display = 'none';
  
  try {
    const data = await api.listContent('notes');
    renderData(data);
  } catch (error) {
    showError('Failed to load data');
  } finally {
    loadingEl.style.display = 'none';
    contentEl.style.display = 'block';
  }
}
```

## Access Control

### Tenant Roles
- **Admin/Owner**: Full CRUD access to all content
- **Member**: Read access, limited write access (implementation specific)
- **Anonymous**: Only if `allowAnonymous: true` in content definition

### Content Definition Access Rules
```typescript
interface DynamicContentAccess {
  tenantRole?: string;        // Required tenant role
  allowAnonymous?: boolean;   // Allow anonymous access
}
```

## Performance Considerations

### 1. Pagination for Large Datasets
```javascript
async function loadNotesWithPagination(page = 1, limit = 20) {
  const offset = (page - 1) * limit;
  const notes = await api.listContent('notes', {
    // Add pagination support when available
    _limit: limit,
    _offset: offset
  });
  return notes;
}
```

### 2. Debounced Search
```javascript
let searchTimeout;
function debouncedSearch(query) {
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(async () => {
    const results = await api.listContent('notes', {
      title: { contains: query }
    });
    displayResults(results);
  }, 300);
}
```

### 3. Local Caching
```javascript
class CachedAPI extends NiaAPI {
  constructor(tenantId, assistantName) {
    super(tenantId, assistantName);
    this.cache = new Map();
  }
  
  async getCachedContent(type, id) {
    const cacheKey = `${type}:${id}`;
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    const content = await this.getContent(type, id);
    this.cache.set(cacheKey, content);
    return content;
  }
}
```

## Testing Generated Applets

### 1. Mock API for Development
```javascript
class MockNiaAPI {
  constructor() {
    this.data = new Map();
  }
  
  async listContent(type) {
    return Array.from(this.data.values()).filter(item => item._type === type);
  }
  
  async createContent(type, data) {
    const item = { ...data, _id: Date.now(), _type: type };
    this.data.set(item._id, item);
    return item;
  }
}

// Use mock in development
const api = process.env.NODE_ENV === 'development' 
  ? new MockNiaAPI() 
  : new NiaAPI(tenantId, assistantName);
```

### 2. Validation Helpers
```javascript
function validateContentSchema(data, schema) {
  // Basic validation - could use a library like Joi or Yup
  for (const field of schema.required || []) {
    if (!data[field]) {
      throw new Error(`Missing required field: ${field}`);
    }
  }
  return true;
}
```

## Troubleshooting

### Common Issues

1. **401 Unauthorized**: User session expired or invalid
   - Solution: Refresh page to get new session

2. **403 Forbidden**: Insufficient permissions
   - Solution: Check content type access rules and user roles

3. **404 Not Found**: Content type or item doesn't exist
   - Solution: Verify content type name and item IDs

4. **400 Bad Request**: Invalid parameters or data format
   - Solution: Check API parameter formatting and data schema

### Debug Mode
```javascript
class DebugNiaAPI extends NiaAPI {
  async makeRequest(url, options) {
    const logger = window.logger ?? { debug: () => {}, info: () => {}, error: () => {} };
    logger.debug('API Request', { url, options });
    const response = await fetch(url, options);
    logger.debug('API Response', { status: response.status, body: await response.clone().text() });
    return response;
  }
}
```

This integration enables powerful, data-driven JavaScript applets that can persist and manipulate structured data while maintaining security and proper access control.
