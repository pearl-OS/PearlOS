<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Polytopia 3D - Mobile Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Fredoka', sans-serif;
            touch-action: none;
            background: #1a1a2e;
        }
        
        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        /* Top UI Bar */
        .top-ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0.4));
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
        }
        
        .score-panel {
            display: flex;
            align-items: center;
            gap: 20px;
            color: white;
        }
        
        .score-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.1);
            padding: 8px 16px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.2);
        }
        
        .score-label {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .score-value {
            font-size: 20px;
            font-weight: 600;
        }
        
        .star-icon {
            font-size: 24px;
        }
        
        .turn-indicator {
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: 600;
            border: 3px solid #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .player-turn {
            color: #4CAF50;
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        .enemy-turn {
            color: #f44336;
            border-color: #f44336;
            box-shadow: 0 0 20px rgba(244, 67, 54, 0.5);
        }
        
        /* Bottom UI */
        .bottom-ui {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0.4));
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
        }
        
        /* Selected Unit Info */
        .unit-info {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            min-width: 200px;
            color: white;
        }
        
        .unit-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .unit-icon {
            font-size: 24px;
        }
        
        .unit-stats {
            display: flex;
            gap: 15px;
            font-size: 14px;
        }
        
        .stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .hp-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .hp-fill {
            height: 100%;
            background: linear-gradient(to right, #f44336, #4CAF50);
            transition: width 0.3s ease;
        }
        
        /* Action Panel - End Turn and Capture */
        .action-panel {
            display: flex;
            gap: 15px;
        }
        
        /* Capture Button */
        .capture-button {
            width: 120px;
            height: 80px;
            background: linear-gradient(135deg, #9C27B0, #7B1FA2);
            border: 3px solid #9C27B0;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
        }
        
        .capture-button:hover {
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.5);
        }
        
        .capture-button:active {
            transform: scale(0.95);
        }
        
        .capture-icon {
            font-size: 32px;
        }
        
        .capture-label {
            font-size: 14px;
            font-weight: 600;
        }
        
        /* End Turn Button */
        .end-turn-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: transparent;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: transform 0.2s, background 0.2s, border-color 0.2s;
            z-index: 1000;
            pointer-events: auto; /* Always clickable */
        }
        
        .end-turn-button.ready {
            background: #4CAF50;
            border-color: #4CAF50;
            color: #fff;
        }
        
        .end-turn-button.bounce {
            animation: bounce 0.8s ease infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        
        /* Camera Controls */
        .camera-controls {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }
        
        .camera-button {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .camera-button:active {
            background: rgba(255,255,255,0.3);
            transform: scale(0.95);
        }
        
        /* Combat Preview */
        .combat-preview {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            border: 3px solid #f44336;
            border-radius: 20px;
            padding: 30px;
            color: white;
            z-index: 2000;
            display: none;
            min-width: 300px;
        }
        
        .combat-title {
            font-size: 24px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .combat-participants {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 30px;
        }
        
        .combat-unit {
            text-align: center;
        }
        
        .combat-unit-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        
        .combat-unit-name {
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .combat-damage {
            font-size: 20px;
            font-weight: 600;
        }
        
        .damage-preview {
            color: #f44336;
        }
        
        .vs-text {
            font-size: 24px;
            font-weight: 600;
            color: #f44336;
        }
        
        /* Terrain Info Panel */
        .terrain-info {
            position: fixed;
            top: 100px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            padding: 15px;
            color: white;
            display: none;
            z-index: 1000;
            min-width: 200px;
        }
        
        .terrain-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .terrain-stats {
            font-size: 14px;
            line-height: 1.6;
        }
        
        .terrain-stat {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }
        
        /* City Menu */
        .city-menu {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            border: 3px solid #4CAF50;
            border-radius: 20px;
            padding: 20px;
            display: none;
            z-index: 1001;
        }
        
        /* Level Up Menu */
        .level-up-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #4CAF50;
            border-radius: 20px;
            padding: 30px;
            z-index: 9999;
            color: white;
            text-align: center;
            min-width: 400px;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        .city-title {
            font-size: 20px;
            font-weight: 600;
            color: white;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .unit-shop {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .unit-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            min-width: 80px;
        }
        
        .unit-card:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
        
        .unit-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .unit-card.disabled:hover {
            transform: none;
        }
        
        .unit-card-icon {
            font-size: 32px;
            margin-bottom: 5px;
        }
        
        .unit-card-name {
            font-size: 12px;
            margin-bottom: 3px;
        }
        
        .unit-card-cost {
            font-size: 14px;
            font-weight: 600;
            color: #FFD700;
        }
        
        /* Tech Tree */
        .tech-tree {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #9C27B0;
            border-radius: 20px;
            padding: 30px;
            display: none;
            z-index: 2000;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .tech-tree-title {
            font-size: 24px;
            font-weight: 600;
            color: white;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .tech-branches {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .tech-branch {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
        }
        
        .tech-branch-name {
            font-size: 18px;
            font-weight: 600;
            color: #9C27B0;
            margin-bottom: 10px;
        }
        
        .tech-items {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .tech-item {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            text-align: center;
            min-width: 100px;
        }
        
        .tech-item:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .tech-item.unlocked {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }
        
        .tech-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-button:hover {
            background: rgba(255,255,255,0.3);
        }
        
        /* Improvement Menu */
        .improvement-menu {
            position: fixed;
            bottom: 140px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            border: 3px solid #FFD700;
            border-radius: 20px;
            padding: 20px;
            display: none;
            z-index: 1001;
            color: white;
        }
        
        .improvement-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .improvement-options {
            display: flex;
            gap: 10px;
        }
        
        .improvement-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 80px;
        }
        
        .improvement-card:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
        
        .improvement-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .improvement-card.disabled:hover {
            transform: none;
        }
        
        .improvement-icon {
            font-size: 32px;
            margin-bottom: 5px;
        }
        
        .improvement-name {
            font-size: 12px;
            margin-bottom: 3px;
        }
        
        .improvement-cost {
            font-size: 14px;
            font-weight: 600;
            color: #FFD700;
        }
        
        .improvement-production {
            font-size: 12px;
            color: #4CAF50;
            margin-top: 3px;
        }
        .research-button {
            position: fixed;
            top: 100px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #9C27B0, #7B1FA2);
            border: 3px solid #9C27B0;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: white;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.2s;
        }
        
        .research-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.5);
        }
        
        .research-button:active {
            transform: scale(0.95);
        }
        /* Loading Screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a2e;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            color: white;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading...</div>
    <div id="gameCanvas"></div>
    
    <!-- Top UI -->
    <div class="top-ui">
        <div class="score-panel">
            <div class="score-item">
                <span class="star-icon">‚≠ê</span>
                <span class="score-value" id="stars">5</span>
            </div>
            <div class="score-item">
                <span class="score-label">Turn</span>
                <span class="score-value" id="turnCount">1</span>
            </div>
        </div>
        <div class="turn-indicator player-turn" id="turnIndicator">
            Player Turn
        </div>
    </div>
    
    <!-- Research Button -->
    <div class="research-button" id="researchBtn">üî¨</div>
    
    <!-- Test Level Up Button (temporary for debugging) -->
    <div class="research-button" id="testLevelUpBtn" style="top: 180px; background: linear-gradient(135deg, #FF9800, #F57C00);">‚≠ê</div>
    
    <!-- Test Population Display Button (temporary for debugging) -->
    <div class="research-button" id="testPopDisplayBtn" style="top: 240px; background: linear-gradient(135deg, #2196F3, #1976D2);">üë•</div>
    
    <!-- Test Level-Up Menu Button (temporary for debugging) -->
    <div class="research-button" id="testLevelUpMenuBtn" style="top: 300px; background: linear-gradient(135deg, #9C27B0, #7B1FA2);">üéØ</div>
    
    <!-- Test Population Progression Button (temporary for debugging) -->
    <div class="research-button" id="testPopProgressionBtn" style="top: 360px; background: linear-gradient(135deg, #4CAF50, #388E3C);">üìà</div>
    
    <!-- Terrain Info Panel -->
    <div class="terrain-info" id="terrainInfo">
        <div class="terrain-name" id="terrainName">Grassland</div>
        <div class="terrain-stats">
            <div class="terrain-stat">
                <span>Defense Bonus:</span>
                <span id="terrainDefense">+0</span>
            </div>
            <div class="terrain-stat">
                <span>Movement Cost:</span>
                <span id="terrainMovement">1</span>
            </div>
            <div class="terrain-stat">
                <span>Features:</span>
                <span id="terrainFeatures">None</span>
            </div>
        </div>
    </div>
    
    <!-- City Menu -->
    <div class="city-menu" id="cityMenu">
        <div class="city-title" id="cityTitle">City Production</div>
        <div class="unit-shop" id="unitShop">
            <!-- Units will be added dynamically -->
        </div>
    </div>
    
    <!-- Improvement Menu -->
    <div class="improvement-menu" id="improvementMenu">
        <div class="improvement-title">Build Improvement</div>
        <div class="improvement-options" id="improvementOptions">
            <!-- Options will be added dynamically -->
        </div>
    </div>
    
    <!-- Tech Tree -->
    <div class="tech-tree" id="techTree">
        <div class="close-button" id="closeTech">√ó</div>
        <div class="tech-tree-title">Research Tree</div>
        <div class="tech-branches">
            <div class="tech-branch">
                <div class="tech-branch-name">Military</div>
                <div class="tech-items">
                    <div class="tech-item" data-tech="archery" title="Unlocks Archer units">
                        <div class="unit-card-icon">üèπ</div>
                        <div>Archery</div>
                        <div class="unit-card-cost">‚≠ê 6</div>
                    </div>
                    <div class="tech-item" data-tech="riding" title="Unlocks Rider units">
                        <div class="unit-card-icon">üêé</div>
                        <div>Riding</div>
                        <div class="unit-card-cost">‚≠ê 5</div>
                    </div>
                    <div class="tech-item" data-tech="shields" title="Unlocks Defender units">
                        <div class="unit-card-icon">üõ°Ô∏è</div>
                        <div>Shields</div>
                        <div class="unit-card-cost">‚≠ê 7</div>
                    </div>
                    <div class="tech-item" data-tech="climbing" title="Allows movement on mountains">
                        <div class="unit-card-icon">üèîÔ∏è</div>
                        <div>Climbing</div>
                        <div class="unit-card-cost">‚≠ê 5</div>
                    </div>
                </div>
            </div>
            <div class="tech-branch">
                <div class="tech-branch-name">Economy</div>
                <div class="tech-items">
                    <div class="tech-item" data-tech="harvesting" title="Harvest fruit and reveals fertile land">
                        <div class="unit-card-icon">üçé</div>
                        <div>Harvesting</div>
                        <div class="unit-card-cost">‚≠ê 4</div>
                    </div>
                    <div class="tech-item" data-tech="farming" title="Build farms on fertile land (requires harvesting)">
                        <div class="unit-card-icon">üåæ</div>
                        <div>Farming</div>
                        <div class="unit-card-cost">‚≠ê 5</div>
                    </div>
                    <div class="tech-item" data-tech="mining" title="Build mines on gold mountains (requires climbing)">
                        <div class="unit-card-icon">‚õèÔ∏è</div>
                        <div>Mining</div>
                        <div class="unit-card-cost">‚≠ê 6</div>
                    </div>
                    <div class="tech-item" data-tech="forestry" title="Build lumber huts in forests">
                        <div class="unit-card-icon">ü™µ</div>
                        <div>Forestry</div>
                        <div class="unit-card-cost">‚≠ê 5</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Bottom UI -->
    <div class="bottom-ui" id="bottomUI" style="display: none;">
        <div class="unit-info" id="unitInfo">
            <div class="unit-name">
                <span class="unit-icon" id="unitIcon">‚öîÔ∏è</span>
                <span id="unitName">Select a unit</span>
            </div>
            <div class="unit-stats">
                <div class="stat">‚ù§Ô∏è <span id="unitHP">0/0</span></div>
                <div class="stat">‚öîÔ∏è <span id="unitATK">0</span></div>
                <div class="stat">üõ°Ô∏è <span id="unitDEF">0</span></div>
                <div class="stat">üëü <span id="unitMoves">0</span></div>
            </div>
            <div class="hp-bar">
                <div class="hp-fill" id="hpFill" style="width: 100%"></div>
            </div>
        </div>
        
        <div class="action-panel">
            <div class="capture-button" id="captureBtn" style="display: none;">
                <span class="capture-icon">üè∞</span>
                <span class="capture-label">Capture</span>
            </div>
            <!-- End turn button moved out -->
        </div>
    </div>
    
    <!-- Persistent End Turn Button -->
    <div class="end-turn-button" id="endTurnBtn">‚úÖ</div>
    
    <!-- Camera Controls -->
    <div class="camera-controls">
        <div class="camera-button" id="zoomIn">+</div>
        <div class="camera-button" id="zoomOut">‚àí</div>
        <div class="camera-button" id="rotateLeft">‚Üª</div>
        <div class="camera-button" id="rotateRight">‚Ü∫</div>
    </div>
    
    <!-- Combat Preview -->
    <div class="combat-preview" id="combatPreview">
        <div class="combat-title">Combat Preview</div>
        <div class="combat-participants">
            <div class="combat-unit">
                <div class="combat-unit-icon" id="attackerIcon">‚öîÔ∏è</div>
                <div class="combat-unit-name" id="attackerName">Warrior</div>
                <div class="combat-damage damage-preview">Counter: <span id="attackerDamage">-5 HP</span></div>
            </div>
            <div class="vs-text">‚öîÔ∏è</div>
            <div class="combat-unit">
                <div class="combat-unit-icon" id="defenderIcon">üõ°Ô∏è</div>
                <div class="combat-unit-name" id="defenderName">Defender</div>
                <div class="combat-damage damage-preview">Damage: <span id="defenderDamage">-3 HP</span></div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Sound Manager
        const soundManager = {
            audioContext: null,
            sounds: {},
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (e) {
                    console.log('Audio not supported');
                }
            },
            
            createSounds() {
                // Attack sound
                this.sounds.attack = () => {
                    if (!this.audioContext) return;
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.2);
                    
                    gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.2);
                };
                
                // Move sound
                this.sounds.move = () => {
                    if (!this.audioContext) return;
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
                
                // Collect sound (like picking up stars)
                this.sounds.collect = () => {
                    if (!this.audioContext) return;
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.15);
                    
                    gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.15);
                };
            },
            
            play(sound) {
                if (this.sounds[sound]) {
                    this.sounds[sound]();
                }
            }
        };
        
        // Initialize sound on first interaction
        document.addEventListener('click', () => {
            if (!soundManager.audioContext) soundManager.init();
        }, { once: true });
        
        // Game Constants
        const TEAM = {
            PLAYER: 'player',
            ENEMY: 'enemy'
        };
        
        const UNIT_TYPES = {
            warrior: {
                hp: 10, maxHp: 10, attack: 2, defense: 2,
                movement: 1, range: 1, icon: 'üòÄ‚öîÔ∏è', cost: 2,
                tech: null // Always available
            },
            archer: {
                hp: 10, maxHp: 10, attack: 2, defense: 1,
                movement: 1, range: 2, icon: 'üòéüèπ', cost: 3,
                tech: 'archery'
            },
            rider: {
                hp: 10, maxHp: 10, attack: 2, defense: 1,
                movement: 2, range: 1, icon: 'ü§†üêé', cost: 3,
                tech: 'riding'
            },
            defender: {
                hp: 15, maxHp: 15, attack: 1, defense: 3,
                movement: 1, range: 1, icon: 'üò§üõ°Ô∏è', cost: 3,
                tech: 'shields'
            }
        };
        
        const TERRAIN_INFO = {
            grass: {
                name: 'Grassland',
                defense: 0,
                movementCost: 1,
                features: 'Basic terrain'
            },
            forest: {
                name: 'Forest',
                defense: 1,
                movementCost: 1,
                features: 'Provides defense bonus'
            },
            mountain: {
                name: 'Mountain',
                defense: 2,
                movementCost: 999, // Changed when climbing is unlocked
                features: 'Requires climbing tech'
            },
            water: {
                name: 'Water',
                defense: 0,
                movementCost: 999,
                features: 'Impassable'
            },
            city: {
                name: 'City',
                defense: 2,
                movementCost: 1,
                features: 'Produces units and stars'
            },
            village: {
                name: 'Village',
                defense: 0,
                movementCost: 1,
                features: 'Can be captured to create city'
            },
            edge: {
                name: 'Edge of World',
                defense: 0,
                movementCost: 999,
                features: 'Impassable boundary'
            }
        };
        
        const TECH_COSTS = {
            archery: 6,
            riding: 5,
            shields: 7,
            farming: 5,
            mining: 6,
            climbing: 5,
            forestry: 5,
            harvesting: 4 // New tech for fruit harvesting and fertile land visibility
        };
        
        const IMPROVEMENT_TYPES = {
            farm: {
                cost: 5,
                production: 2,
                icon: 'üåæ',
                tech: 'farming',
                validTerrain: ['grass'], // Only on fertile grass
                requiresResource: true // Needs fertile land
            },
            mine: {
                cost: 5,
                production: 2,
                icon: '‚õèÔ∏è',
                tech: 'mining',
                validTerrain: ['mountain'], // Only on gold mountains
                requiresResource: true // Needs gold deposit
            },
            lumber_hut: {
                cost: 2,
                production: 1,
                icon: 'ü™µ',
                tech: 'forestry',
                validTerrain: ['forest'],
                requiresResource: false // Any forest
            },
            orchard: {
                cost: 4,
                production: 1,
                icon: 'üçé',
                tech: 'harvesting',
                validTerrain: ['grass'],
                requiresResource: 'fruit' // Needs fruit resource
            }
        };
        
        // Tech prerequisites (Polytopia-style)
        const TECH_PREREQUISITES = {
            farming: ['harvesting'], // Harvesting unlocks farming
            mining: ['climbing'], // Climbing unlocks mining
            forestry: [], // No prerequisites
            harvesting: [], // No prerequisites
            climbing: [], // No prerequisites
            archery: [], // No prerequisites
            riding: [], // No prerequisites
            shields: [] // No prerequisites
        };
        
        // Enemy emoji types
        const ENEMY_EMOJI_TYPES = [
            { face: 'üëæ', weapon: '‚öîÔ∏è' }, // Alien
            { face: 'üê∫', weapon: '‚öîÔ∏è' }, // Wolf
            { face: 'ü¶Å', weapon: '‚öîÔ∏è' }, // Lion
            { face: 'üêØ', weapon: '‚öîÔ∏è' }, // Tiger
            { face: 'üëπ', weapon: '‚öîÔ∏è' }, // Ogre
            { face: 'üëª', weapon: '‚öîÔ∏è' }, // Ghost
            { face: 'ü¶à', weapon: '‚öîÔ∏è' }, // Shark
            { face: 'ü¶Ö', weapon: '‚öîÔ∏è' }  // Eagle
        ];
        
        // Random city names (Polytopia style)
        const CITY_NAMES = [
            'Tekca', 'Talya', 'Lakgru', 'Bugucha', 'Vedra', 'Korita', 'Nubara', 'Zebasi',
            'Imperius', 'Bardur', 'Oumaji', 'Kickoo', 'Hoodrick', 'Luxidoor', 'Vengir',
            'Ai-Mo', 'Quetzali', 'Yadakk', 'Xin-xi', 'Aquarion', 'Polaris', 'Cymanti'
        ];
        
        // Game State
        const gameState = {
            turn: 1,

            stars: 5,
            currentTeam: TEAM.PLAYER,
            selectedUnit: null,
            selectedTile: null,
            selectedCity: null,
            camera: null,
            scene: null,
            renderer: null,
            raycaster: new THREE.Raycaster(),
            tiles: [],
            units: [],
            cities: [],
            unlockedTech: {
                player: [],
                enemy: ['archery', 'forestry'] // Enemy starts with archery and forestry
            },
            touchStartPos: null,
            lastTouchTime: 0,
            isDragging: false,
            pinchDistance: 0,
            validMoves: [],
            validAttacks: [],
            tileHighlights: new Map(),
            isAnimating: false,
            exploredTiles: new Set(), // For fog of war
            fogTiles: new Map(), // Fog overlay meshes
            roads: [], // Road connections between cities
            enemyEmojiType: ENEMY_EMOJI_TYPES[Math.floor(Math.random() * ENEMY_EMOJI_TYPES.length)] // Random enemy type
        };
        
        // Initialize Scene
        function initScene() {
            // Scene setup
            gameState.scene = new THREE.Scene();
            gameState.scene.background = new THREE.Color(0x87CEEB); // Sky blue
            // Reduce built-in scene fog so board isn't hazy
            gameState.scene.fog = new THREE.Fog(0x87CEEB, 100, 200); // Starts far away
            
            // Camera setup
            const aspect = window.innerWidth / window.innerHeight;
            gameState.camera = new THREE.OrthographicCamera(
                -20 * aspect, 20 * aspect, 20, -20, 0.1, 1000
            );
            gameState.camera.position.set(25, 25, 25);
            gameState.camera.lookAt(0, 0, 0);
            
            // Renderer setup
            gameState.renderer = new THREE.WebGLRenderer({ antialias: true });
            gameState.renderer.setSize(window.innerWidth, window.innerHeight);
            gameState.renderer.shadowMap.enabled = true;
            gameState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameCanvas').appendChild(gameState.renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Brighter ambient
            gameState.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Brighter directional
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            gameState.scene.add(directionalLight);
            
            // Generate map
            generateMap();
            
            // Place initial units
            placeInitialUnits();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
        }
        
        // Generate map
        function generateMap() {
            const mapSize = 16; // Much larger map
            
            // Create village grid with spacing (Polytopia-style distribution)
            // Ensure at least 3 squares distance between villages (5x5 exclusion zone)
            const villagePositions = [];
            for (let x = -mapSize/2 + 3; x <= mapSize/2 - 3; x += 5) {
                for (let z = -mapSize/2 + 3; z <= mapSize/2 - 3; z += 5) {
                    if (Math.random() < 0.7) { // 70% chance per grid position
                        villagePositions.push({x, z});
                    }
                }
            }
            
            // Store starting positions for resource distribution
            gameState.startingPositions = [];
            
            for (let x = -mapSize/2; x <= mapSize/2; x++) {
                for (let z = -mapSize/2; z <= mapSize/2; z++) {
                    // Check if this should be a village
                    const isVillage = villagePositions.some(v => 
                        Math.abs(v.x - x) <= 0 && Math.abs(v.z - z) <= 0
                    );
                    
                    if (isVillage) {
                        createTile(x, z, mapSize, 'village');
                        // Mark as potential starting position
                        gameState.startingPositions.push({x, z});
                    } else {
                        createTile(x, z, mapSize);
                    }
                }
            }
        }
        
        // Create tile
        function createTile(x, z, mapSize, forcedType = null) {
            const geometry = new THREE.BoxGeometry(0.95, 0.4, 0.95);
            
            // Check if this is an edge tile
            const isEdge = Math.abs(x) === mapSize/2 || Math.abs(z) === mapSize/2;
            
            // Determine tile type
            const rand = Math.random();
            let type = forcedType || (isEdge ? 'edge' : 'grass');
            let color = isEdge ? 0x0a0a0a : 0x7CB342;
            let hasResource = false;
            
            // Don't change type for edge tiles
            if (!isEdge && !forcedType) {
                if (rand < 0.15) {
                    type = 'water';
                    color = 0x2980b9;
                } else if (rand < 0.25) {
                    type = 'forest';
                    color = 0x4CAF50;
                } else if (rand < 0.3) {
                    type = 'mountain';
                    color = 0x757575; // Lighter grey for mountains
                    // 30% chance of gold in mountains
                    hasResource = Math.random() < 0.3;
                } else {
                    // Grass tiles - 20% chance of being fertile
                    if (Math.random() < 0.2) {
                        hasResource = true; // fertile
                    }
                    // 10% chance of having fruit
                    if (Math.random() < 0.1) {
                        hasResource = 'fruit';
                    }
                }
            } else if (forcedType === 'village') {
                type = 'village';
                color = 0x7CB342;
                // Villages have higher chance of resources
                if (Math.random() < 0.4) {
                    hasResource = true; // fertile
                }
                if (Math.random() < 0.3) {
                    hasResource = 'fruit';
                }
            }
            
            const material = new THREE.MeshPhongMaterial({
                color: color,
                flatShading: true
            });
            
            const tile = new THREE.Mesh(geometry, material);
            tile.position.set(x, type === 'water' ? -0.2 : 0, z);
            tile.castShadow = true;
            tile.receiveShadow = true;
            
            // Start with tile hidden
            tile.visible = false;
            
            tile.userData = {
                x: x,
                z: z,
                type: type,
                unit: null,
                feature: null,
                improvement: null,
                owner: null,
                resource: hasResource, // true for fertile/gold, 'fruit' for fruit
                borderIndicators: [], // For storing border meshes
                isEdge: isEdge // Mark edge tiles
            };
            
            gameState.tiles.push(tile);
            gameState.scene.add(tile);
            
            // Add features
            if (type === 'forest') {
                addForest(x, z, tile);
            } else if (type === 'mountain') {
                addMountain(x, z, tile, hasResource);
            } else if (type === 'village') {
                addVillage(x, z, tile);
            } else if (type === 'grass' && hasResource === 'fruit') {
                addFruit(x, z, tile);
            }
            
            // Add selection indicator
            const indicatorGeometry = new THREE.BoxGeometry(1.1, 0.1, 1.1);
            const indicatorMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0
            });
            const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
            indicator.position.copy(tile.position);
            indicator.position.y = 0.25;
            indicator.visible = false;
            tile.userData.indicator = indicator;
            gameState.scene.add(indicator);
            
            // Add cloud fog sprite
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Draw simple cloud covering
            ctx.fillStyle = 'rgba(240, 240, 240, 0.9)';
            
            // Draw overlapping circles to create cloud effect
            const cloudPositions = [
                { x: 64, y: 64, r: 50 },
                { x: 128, y: 64, r: 60 },
                { x: 192, y: 64, r: 50 },
                { x: 64, y: 128, r: 60 },
                { x: 128, y: 128, r: 70 },
                { x: 192, y: 128, r: 60 },
                { x: 64, y: 192, r: 50 },
                { x: 128, y: 192, r: 60 },
                { x: 192, y: 192, r: 50 }
            ];
            
            cloudPositions.forEach(cloud => {
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.r, 0, Math.PI * 2);
                ctx.fill();
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const fogMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.8,
                depthWrite: false
            });
            const fogSprite = new THREE.Sprite(fogMaterial);
            fogSprite.scale.set(1.2, 1.2, 1);
            fogSprite.position.copy(tile.position);
            fogSprite.position.y = 0.5;
            tile.userData.fog = fogSprite;
            fogSprite.visible = false; // Start hidden
            gameState.fogTiles.set(tile, fogSprite);
            gameState.scene.add(fogSprite);
        }
        
        // Add forest
        function addForest(x, z, tile) {
            const group = new THREE.Group();
            
            for (let i = 0; i < 3; i++) {
                const treeGroup = new THREE.Group();
                
                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.3, 6);
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x6D4C41 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 0.15;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                
                // Leaves
                const leavesGeometry = new THREE.ConeGeometry(0.15, 0.3, 6);
                const leavesMaterial = new THREE.MeshPhongMaterial({ color: 0x2E7D32 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 0.35;
                leaves.castShadow = true;
                treeGroup.add(leaves);
                
                treeGroup.position.set(
                    (Math.random() - 0.5) * 0.3,
                    0,
                    (Math.random() - 0.5) * 0.3
                );
                
                group.add(treeGroup);
            }
            
            group.position.set(x, 0.2, z);
            tile.userData.feature = group;
            group.visible = false; // Hidden by fog initially
            gameState.scene.add(group);
        }
        
        // Add mountain
        function addMountain(x, z, tile, hasGold = false) {
            const mountain = new THREE.Group();
            
            // Main peak
            const geometry = new THREE.ConeGeometry(0.4, 0.8, 8);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x757575,
                flatShading: true
            });
            const peak = new THREE.Mesh(geometry, material);
            peak.position.y = 0.4;
            peak.castShadow = true;
            mountain.add(peak);
            
            // Snow cap
            const snowGeometry = new THREE.ConeGeometry(0.2, 0.2, 8);
            const snowMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const snow = new THREE.Mesh(snowGeometry, snowMaterial);
            snow.position.y = 0.7;
            mountain.add(snow);
            
            // Add gold veins if mountain has gold
            if (hasGold) {
                const goldMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFFD700,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.3
                });
                
                // Gold veins on mountain sides
                for (let i = 0; i < 3; i++) {
                    const goldGeometry = new THREE.BoxGeometry(0.05, 0.2, 0.02);
                    const gold = new THREE.Mesh(goldGeometry, goldMaterial);
                    const angle = (i / 3) * Math.PI * 2;
                    gold.position.set(
                        Math.cos(angle) * 0.25,
                        0.3 + Math.random() * 0.2,
                        Math.sin(angle) * 0.25
                    );
                    gold.rotation.y = angle;
                    gold.rotation.z = (Math.random() - 0.5) * 0.5;
                    mountain.add(gold);
                }
            }
            
            mountain.position.set(x, 0.2, z);
            tile.userData.feature = mountain;
            mountain.visible = false; // Hidden by fog initially
            gameState.scene.add(mountain);
        }
        
        // Add fruit
        function addFruit(x, z, tile) {
            const fruitGroup = new THREE.Group();
            
            // Bush
            const bushGeometry = new THREE.SphereGeometry(0.2, 8, 6);
            const bushMaterial = new THREE.MeshPhongMaterial({ color: 0x4CAF50 });
            const bush = new THREE.Mesh(bushGeometry, bushMaterial);
            bush.position.y = 0.1;
            bush.scale.y = 0.6;
            fruitGroup.add(bush);
            
            // Fruits (berries)
            const fruitMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xE91E63,
                emissive: 0xE91E63,
                emissiveIntensity: 0.2
            });
            
            for (let i = 0; i < 5; i++) {
                const fruit = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 6, 6),
                    fruitMaterial
                );
                const angle = (i / 5) * Math.PI * 2;
                fruit.position.set(
                    Math.cos(angle) * 0.15,
                    0.1 + Math.random() * 0.1,
                    Math.sin(angle) * 0.15
                );
                fruitGroup.add(fruit);
            }
            
            fruitGroup.position.set(x, 0.2, z);
            tile.userData.feature = fruitGroup;
            fruitGroup.visible = false; // Hidden by fog initially
            gameState.scene.add(fruitGroup);
        }
        
        // Add village
        function addVillage(x, z, tile) {
            const village = new THREE.Group();
            
            // Create 2-3 small houses
            for (let i = 0; i < 2; i++) {
                const house = new THREE.Group();
                
                // House base
                const houseGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
                const houseMaterial = new THREE.MeshPhongMaterial({ color: 0xD7CCC8 });
                const houseBase = new THREE.Mesh(houseGeometry, houseMaterial);
                houseBase.position.y = 0.075;
                house.add(houseBase);
                
                // Roof
                const roofGeometry = new THREE.ConeGeometry(0.12, 0.1, 4);
                const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x8D6E63 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = 0.2;
                roof.rotation.y = Math.PI / 4;
                house.add(roof);
                
                house.position.set(
                    (i - 0.5) * 0.2,
                    0,
                    (Math.random() - 0.5) * 0.1
                );
                house.castShadow = true;
                
                village.add(house);
            }
            
            village.position.set(x, 0.2, z);
            tile.userData.feature = village;
            village.visible = false; // Hidden by fog initially
            gameState.scene.add(village);
        }
        
        // Reveal tiles around a position (Polytopia: 3x3 vision radius, +1 with climbing, +1 on mountains)
        function revealTiles(centerTile, range = 1) {
            // Add +1 vision range if climbing is researched
            if (gameState.unlockedTech.player.includes('climbing')) {
                range += 1;
            }
            
            // Add +1 vision range if on mountain
            if (centerTile.userData.type === 'mountain') {
                range += 1;
            }
            const tilesToReveal = [centerTile];
            const neighbors = getNeighbors(centerTile, range);
            tilesToReveal.push(...neighbors);
            
            tilesToReveal.forEach(tile => {
                if (!gameState.exploredTiles.has(tile)) {
                    gameState.exploredTiles.add(tile);
                    
                    // Show the tile
                    tile.visible = true;
                    
                    // Show any features on this tile
                    if (tile.userData.feature) {
                        tile.userData.feature.visible = true;
                    }
                    
                    // Show any cities on this tile
                    if (tile.userData.city) {
                        tile.userData.city.model.visible = true;
                    }
                    
                    // Show any improvements on this tile
                    if (tile.userData.improvementVisual) {
                        tile.userData.improvementVisual.visible = true;
                    }
                    
                    // Show territory glow if owned
                    if (tile.userData.territoryGlow && tile.userData.owner) {
                        tile.userData.territoryGlow.visible = true;
                    }
                    
                    // Show resource indicators if tech is unlocked
                    if (tile.userData.resource === true) {
                        if (tile.userData.type === 'grass' && gameState.unlockedTech.player.includes('harvesting') && 
                            gameState.exploredTiles.has(tile)) {
                            // Add subtle fertile indicator
                            if (!tile.userData.resourceIndicator) {
                                const fertileGeometry = new THREE.PlaneGeometry(0.3, 0.3);
                                const fertileMaterial = new THREE.MeshBasicMaterial({ 
                                    color: 0x8BC34A,
                                    transparent: true,
                                    opacity: 0.6,
                                    side: THREE.DoubleSide
                                });
                                const fertile = new THREE.Mesh(fertileGeometry, fertileMaterial);
                                fertile.rotation.x = -Math.PI / 2;
                                fertile.position.copy(tile.position);
                                fertile.position.y = 0.21;
                                tile.userData.resourceIndicator = fertile;
                                gameState.scene.add(fertile);
                            }
                            tile.userData.resourceIndicator.visible = true;
                        } else if (tile.userData.type === 'mountain' && gameState.unlockedTech.player.includes('climbing') && 
                            gameState.exploredTiles.has(tile)) {
                            // Add gold deposit indicator
                            if (!tile.userData.resourceIndicator) {
                                const goldGeometry = new THREE.PlaneGeometry(0.3, 0.3);
                                const goldMaterial = new THREE.MeshBasicMaterial({ 
                                    color: 0xFFD700,
                                    transparent: true,
                                    opacity: 0.8,
                                    side: THREE.DoubleSide
                                });
                                const gold = new THREE.Mesh(goldGeometry, goldMaterial);
                                gold.rotation.x = -Math.PI / 2;
                                gold.position.copy(tile.position);
                                gold.position.y = 0.21;
                                tile.userData.resourceIndicator = gold;
                                gameState.scene.add(gold);
                            }
                            tile.userData.resourceIndicator.visible = true;
                        }
                    }
                    
                    // Show indicator if it exists
                    if (tile.userData.indicator) {
                        // Don't show it here, only when highlighted
                    }
                }
            });
            
            // Update fog sprites for partial visibility
            updateFogOfWar();
            
            // Update borders when revealing new tiles
            updateTerritoryBorders();
        }
        
        // Update fog of war sprites
        function updateFogOfWar() {
            // Full fog-of-war: hide unexplored tiles with white clouds; keep explored tiles clear.
            gameState.tiles.forEach(tile => {
                const fogSprite = tile.userData.fog;
                if (!fogSprite) return;

                const explored = gameState.exploredTiles.has(tile);

                // Toggle visibility of tile & objects
                tile.visible = explored;
                if (tile.userData.feature) tile.userData.feature.visible = explored;
                if (tile.userData.city) tile.userData.city.model.visible = explored;
                if (tile.userData.improvementVisual) tile.userData.improvementVisual.visible = explored;

                // Fog sprite logic
                if (explored) {
                    fogSprite.visible = false;
                } else {
                    fogSprite.visible = true;
                    // Heavier opacity in deep fog, lighter on frontier
                    const neighbors = getNeighbors(tile, 1);
                    const edgeOfVision = neighbors.some(n => gameState.exploredTiles.has(n));
                    fogSprite.material.opacity = edgeOfVision ? 0.4 : 0.8;
                }
            });
        }
        
        // Update fog visibility for enemy units
        function updateEnemyVisibility() {
            // Hide all enemy units first
            gameState.units.forEach(unit => {
                if (unit.userData.team === TEAM.ENEMY) {
                    unit.visible = false;
                }
            });
            
            // Show enemy units in visible tiles
            gameState.units.forEach(unit => {
                if (unit.userData.team === TEAM.ENEMY && 
                    unit.userData.tile.visible && // Check if tile is visible
                    gameState.exploredTiles.has(unit.userData.tile)) {
                    
                    // Check if any player unit can see this tile
                    let isVisible = false;
                    gameState.units.forEach(playerUnit => {
                        if (playerUnit.userData.team === TEAM.PLAYER) {
                            const distance = Math.abs(unit.userData.tile.userData.x - playerUnit.userData.tile.userData.x) +
                                           Math.abs(unit.userData.tile.userData.z - playerUnit.userData.tile.userData.z);
                            if (distance <= 2) {
                                isVisible = true;
                            }
                        }
                    });
                    
                    // Also check cities
                    gameState.cities.forEach(city => {
                        if (city.team === TEAM.PLAYER) {
                            const cityTile = gameState.tiles.find(t => t.userData.city === city);
                            if (cityTile) {
                                const distance = Math.abs(unit.userData.tile.userData.x - cityTile.userData.x) +
                                               Math.abs(unit.userData.tile.userData.z - cityTile.userData.z);
                                if (distance <= 2) {
                                    isVisible = true;
                                }
                            }
                        }
                    });
                    
                    unit.visible = isVisible;
                }
            });
            
            // Always update fog of war when visibility changes
            updateFogOfWar();
        }
        
        // Ensure rich resource distribution around starting cities (Polytopia style)
        function ensureRichResourceDistribution() {
            // Get all cities and villages
            const cities = gameState.cities;
            const villages = gameState.tiles.filter(t => t.userData.type === 'village');
            
            // Process cities
            cities.forEach(city => {
                const cityTile = gameState.tiles.find(t => t.userData.city === city);
                if (!cityTile) return;
                
                addResourcesAroundTile(cityTile, 3); // More resources around cities
            });
            
            // Process villages
            villages.forEach(villageTile => {
                addResourcesAroundTile(villageTile, 2); // Some resources around villages
            });
        }
        
        // Add resources around a specific tile
        function addResourcesAroundTile(tile, resourceCount) {
            // Get tiles within 3x3 radius of tile
            const neighbors = getNeighbors(tile, 1);
            const availableTiles = neighbors.filter(t => 
                t.userData.type === 'grass' && 
                !t.userData.resource && 
                !t.userData.improvement &&
                !t.userData.city &&
                !t.userData.feature
            );
            
            if (availableTiles.length === 0) return;
            
            // Add multiple resources
            for (let i = 0; i < resourceCount && availableTiles.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableTiles.length);
                const targetTile = availableTiles.splice(randomIndex, 1)[0];
                
                // Randomly choose resource type
                const resourceType = Math.random();
                
                if (resourceType < 0.3) {
                    // Add fertile land
                    targetTile.userData.resource = true;
                    targetTile.material.color.setHex(0x8BC34A); // Slightly greener for fertile
                } else if (resourceType < 0.6) {
                    // Add fruit
                    targetTile.userData.resource = 'fruit';
                    addFruit(targetTile.userData.x, targetTile.userData.z, targetTile);
                } else if (resourceType < 0.85) {
                    // Add forest
                    targetTile.userData.type = 'forest';
                    targetTile.material.color.setHex(0x4CAF50);
                    addForest(targetTile.userData.x, targetTile.userData.z, targetTile);
                } else {
                    // Add mountain with gold
                    targetTile.userData.type = 'mountain';
                    targetTile.userData.resource = true; // Gold deposit
                    targetTile.material.color.setHex(0x757575);
                    addMountain(targetTile.userData.x, targetTile.userData.z, targetTile, true);
                }
            }
        }
        
        // Place initial units
        function placeInitialUnits() {
            // Find good starting positions
            const grassTiles = gameState.tiles.filter(t => 
                t.userData.type === 'grass' && 
                Math.abs(t.userData.x) < 6 && 
                Math.abs(t.userData.z) < 6
            );
            
            if (grassTiles.length >= 4) {
                // Player start - 1 warrior and 1 city
                const playerStart = grassTiles[Math.floor(Math.random() * grassTiles.length / 4)];
                createCity(playerStart.userData.x, playerStart.userData.z, TEAM.PLAYER, 'Capital');
                
                // Reveal tiles around player start (cities have 5x5 vision)
                revealTiles(playerStart, 2);
                
                // Place warrior in the city
                createUnit(playerStart.userData.x, playerStart.userData.z, 'warrior', TEAM.PLAYER);
                // Starting units can move on first turn
                const warrior = gameState.units.find(u => u.userData.tile === playerStart);
                if (warrior) {
                    warrior.userData.movesLeft = warrior.userData.movement;
                }
                
                // Make sure starting city is visible
                if (playerStart.userData.city) {
                    playerStart.userData.city.model.visible = true;
                }
                
                // Enemy tribes - place 2-3 enemy tribes spread around the map
                const enemyCount = 2; // Start with 2 enemy tribes
                const usedTiles = [playerStart];
                
                for (let i = 0; i < enemyCount; i++) {
                    // Find a tile far from other starts
                    let enemyStart = null;
                    let maxMinDist = 0;
                    
                    grassTiles.forEach(tile => {
                        let minDist = Infinity;
                        usedTiles.forEach(used => {
                            const dist = Math.abs(tile.userData.x - used.userData.x) + 
                                       Math.abs(tile.userData.z - used.userData.z);
                            minDist = Math.min(minDist, dist);
                        });
                        
                        if (minDist > maxMinDist && minDist > 8) { // Ensure good spacing
                            maxMinDist = minDist;
                            enemyStart = tile;
                        }
                    });
                    
                    if (enemyStart) {
                        createCity(enemyStart.userData.x, enemyStart.userData.z, TEAM.ENEMY, `Enemy Tribe ${i + 1}`);
                        
                        // Place warrior in the city
                        createUnit(enemyStart.userData.x, enemyStart.userData.z, 'warrior', TEAM.ENEMY);
                        // Enemy starting units can also move
                        const enemyWarrior = gameState.units.find(u => u.userData.tile === enemyStart);
                        if (enemyWarrior) {
                            enemyWarrior.userData.movesLeft = enemyWarrior.userData.movement;
                        }
                        
                        usedTiles.push(enemyStart);
                    }
                }
            }
            
            // Ensure rich resource distribution around starting cities
            ensureRichResourceDistribution();
            
            // Initial visibility update
            updateEnemyVisibility();
            
            // Update territory borders
            updateTerritoryBorders();
            
            // Initial city populations - skip automatic calculation to start with blank pips
            // Cities will start with 0 population points and 2 blank white pips
            
            // Roads removed for now
            
            // Add helper to check if all player units have moved and update button state
            checkAllUnitsMoved();
            selectNextUnmovedUnit();
        }
        
        // Update territory borders with better visualization
        function updateTerritoryBorders() {
            // Clear existing borders
            gameState.tiles.forEach(tile => {
                tile.userData.borderIndicators.forEach(border => {
                    gameState.scene.remove(border);
                });
                tile.userData.borderIndicators = [];
            });
            
            // Create new borders with corner pieces
            gameState.tiles.forEach(tile => {
                if (!tile.userData.owner || !tile.visible) return;
                
                const owner = tile.userData.owner;
                const borderColor = owner === TEAM.PLAYER ? 0x2196F3 : 0xf44336; // Blue for player
                const borderMaterial = new THREE.MeshPhongMaterial({ 
                    color: borderColor,
                    transparent: true,
                    opacity: 0.8,
                    emissive: borderColor,
                    emissiveIntensity: 0.3
                });
                
                // Check each direction for border
                const directions = [
                    { dx: 0, dz: -1, rotation: 0, pos: 'north' },
                    { dx: 1, dz: 0, rotation: Math.PI / 2, pos: 'east' },
                    { dx: 0, dz: 1, rotation: Math.PI, pos: 'south' },
                    { dx: -1, dz: 0, rotation: -Math.PI / 2, pos: 'west' }
                ];
                
                directions.forEach((dir, index) => {
                    const neighbor = gameState.tiles.find(t => 
                        t.userData.x === tile.userData.x + dir.dx && 
                        t.userData.z === tile.userData.z + dir.dz
                    );
                    
                    // Add border if neighbor has different owner or doesn't exist
                    if (!neighbor || neighbor.userData.owner !== owner) {
                        const borderGeometry = new THREE.BoxGeometry(0.95, 0.2, 0.08);
                        const border = new THREE.Mesh(borderGeometry, borderMaterial);
                        
                        // Position border at edge of tile
                        border.position.set(
                            tile.position.x + dir.dx * 0.475,
                            0.1,
                            tile.position.z + dir.dz * 0.475
                        );
                        border.rotation.y = dir.rotation;
                        border.castShadow = true;
                        
                        tile.userData.borderIndicators.push(border);
                        gameState.scene.add(border);
                        
                        // Add corner pieces for smoother borders
                        const nextDir = directions[(index + 1) % 4];
                        const nextNeighbor = gameState.tiles.find(t => 
                            t.userData.x === tile.userData.x + nextDir.dx && 
                            t.userData.z === tile.userData.z + nextDir.dz
                        );
                        const diagonalNeighbor = gameState.tiles.find(t => 
                            t.userData.x === tile.userData.x + dir.dx + nextDir.dx && 
                            t.userData.z === tile.userData.z + dir.dz + nextDir.dz
                        );
                        
                        // Add corner if we have borders on two adjacent sides
                        if ((!nextNeighbor || nextNeighbor.userData.owner !== owner) &&
                            (!diagonalNeighbor || diagonalNeighbor.userData.owner !== owner)) {
                            const cornerGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.2, 8);
                            const corner = new THREE.Mesh(cornerGeometry, borderMaterial);
                            corner.position.set(
                                tile.position.x + (dir.dx + nextDir.dx) * 0.475,
                                0.1,
                                tile.position.z + (dir.dz + nextDir.dz) * 0.475
                            );
                            corner.castShadow = true;
                            tile.userData.borderIndicators.push(corner);
                            gameState.scene.add(corner);
                        }
                    }
                });
                
                // Add subtle territory glow
                if (!tile.userData.territoryGlow) {
                    const glowGeometry = new THREE.PlaneGeometry(0.9, 0.9);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: borderColor,
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.DoubleSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.rotation.x = -Math.PI / 2;
                    glow.position.copy(tile.position);
                    glow.position.y = 0.21;
                    tile.userData.territoryGlow = glow;
                    gameState.scene.add(glow);
                } else {
                    tile.userData.territoryGlow.material.color.setHex(borderColor);
                    tile.userData.territoryGlow.visible = true;
                }
            });
        }
        
        // Create roads between cities
        function createRoadsBetweenCities() {
            // Remove existing roads
            if (gameState.roads) {
                gameState.roads.forEach(road => gameState.scene.remove(road));
            }
            gameState.roads = [];
            
            // Find all player cities
            const playerCities = [];
            gameState.tiles.forEach(tile => {
                if (tile.userData.city && tile.userData.city.team === TEAM.PLAYER) {
                    playerCities.push(tile);
                }
            });
            
            // Create roads between nearby cities
            playerCities.forEach((cityA, indexA) => {
                playerCities.forEach((cityB, indexB) => {
                    if (indexA >= indexB) return; // Avoid duplicates
                    
                    const distance = Math.abs(cityA.userData.x - cityB.userData.x) + 
                                   Math.abs(cityA.userData.z - cityB.userData.z);
                    
                    // Connect cities within reasonable distance
                    if (distance <= 6) {
                        // Create simple road path (straight line for now)
                        const roadGeometry = new THREE.BoxGeometry(0.3, 0.01, distance);
                        const roadMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0x8B7355,
                            emissive: 0x8B7355,
                            emissiveIntensity: 0.1
                        });
                        const road = new THREE.Mesh(roadGeometry, roadMaterial);
                        
                        // Position and rotate road
                        const midX = (cityA.position.x + cityB.position.x) / 2;
                        const midZ = (cityA.position.z + cityB.position.z) / 2;
                        road.position.set(midX, 0.21, midZ);
                        
                        // Calculate rotation
                        const angle = Math.atan2(
                            cityB.position.z - cityA.position.z,
                            cityB.position.x - cityA.position.x
                        );
                        road.rotation.y = -angle;
                        
                        gameState.roads.push(road);
                        gameState.scene.add(road);
                    }
                });
            });
        }
        
        // Create city population display (Polytopia style)
        function createCityPopulationDisplay(cityGroup, population, city) {
            // Debug: Log population display creation
            console.log(`Creating population display for ${city.name}:`);
            console.log(`- Population parameter: ${population}`);
            console.log(`- City populationPoints: ${city.populationPoints}`);
            console.log(`- City level: ${city.level}`);
            
            // Remove old population display if exists
            const oldDisplay = cityGroup.getObjectByName('populationDisplay');
            if (oldDisplay) {
                cityGroup.remove(oldDisplay);
            }
            
            // Create sprite for city info display
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Clear background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, 512, 128);
            
            // City name
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(city.name, 20, 40);
            
            // Star production
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('‚≠ê ' + city.production, 20, 70);
            
            // Population segments (2 white slots that fill blue - Polytopia style)
            const segmentStartX = 200;
            const segmentY = 64;
            const segmentWidth = 15;
            const segmentHeight = 8;
            const segmentSpacing = 5;
            const segmentCount = 2;
            
            // Calculate how many segments should be filled based on population points
            // Each level has 2 population points maximum
            // Level 1: 0-2 population points (0-2 segments)
            // Level 2: 0-2 population points (0-2 segments) 
            // Level 3: 0-2 population points (0-2 segments)
            // etc.
            const populationPoints = city.populationPoints || 0;
            
            // Show population progress for current level
            // Each level requires 2 population points to fill both segments
            // Level 1: 0-2 points, Level 2: 2-4 points, Level 3: 4-6 points, etc.
            const levelStartPoints = (city.level - 1) * 2;
            const populationForCurrentLevel = Math.max(0, populationPoints - levelStartPoints);
            const filledSegments = Math.min(segmentCount, populationForCurrentLevel);
            
            // Show the actual number of filled segments (0, 1, or 2)
            const displaySegments = filledSegments;
            
            // Debug: Log the calculation details
            console.log(`Population display calculation for ${city.name}:`);
            console.log(`  - Total population points: ${populationPoints}`);
            console.log(`  - Current level: ${city.level}`);
            console.log(`  - Level start points: ${levelStartPoints}`);
            console.log(`  - Population for current level: ${populationForCurrentLevel}`);
            console.log(`  - Filled segments: ${filledSegments}`);
            console.log(`  - Display segments: ${displaySegments}`);
            
            // Debug: Log segment calculation
            console.log(`=== POPULATION DISPLAY DEBUG ===`);
            console.log(`City: ${city.name}`);
            console.log(`- Population points: ${populationPoints}`);
            console.log(`- Level: ${city.level}`);
            console.log(`- Level start points: ${levelStartPoints}`);
            console.log(`- Population for current level: ${populationForCurrentLevel}`);
            console.log(`- Filled segments: ${filledSegments}`);
            console.log(`- Display segments: ${displaySegments}`);
            console.log(`- Segment count: ${segmentCount}`);
            
            // Draw white segments
            for (let i = 0; i < segmentCount; i++) {
                const segmentX = segmentStartX + i * (segmentWidth + segmentSpacing);
                
                // White segment background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(segmentX, segmentY - segmentHeight/2, segmentWidth, segmentHeight);
                
                // Border
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(segmentX, segmentY - segmentHeight/2, segmentWidth, segmentHeight);
                
                // Fill with blue if this segment should be filled
                if (i < displaySegments) {
                    ctx.fillStyle = '#2196F3';
                    ctx.fillRect(segmentX + 1, segmentY - segmentHeight/2 + 1, segmentWidth - 2, segmentHeight - 2);
                }
            }
            
            // Add level-up indicator if all segments are filled
            if (displaySegments === segmentCount) {
                // Add a small star indicator
                ctx.fillStyle = '#FFD700';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚≠ê', segmentStartX + (segmentCount * (segmentWidth + segmentSpacing)) + 15, segmentY);
                
                // Also add a pulsing effect for level-up readiness
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fillRect(segmentStartX - 5, segmentY - segmentHeight/2 - 5, 
                           (segmentCount * (segmentWidth + segmentSpacing)) + 10, segmentHeight + 10);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                sizeAttenuation: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(1.2, 0.3, 1);
            sprite.position.y = 1.2;
            sprite.name = 'populationDisplay';
            cityGroup.add(sprite);
        }
        
        // Create city
        function createCity(x, z, team, name) {
            const tile = gameState.tiles.find(t => t.userData.x === x && t.userData.z === z);
            if (!tile || tile.userData.type === 'water' || tile.userData.type === 'mountain' || tile.userData.isEdge) return;
            
            // If there's already a city here, just update it
            if (tile.userData.city) {
                captureCity(tile, team);
                return;
            }
            
            // Use random name if not provided
            if (!name || name === 'New City') {
                const randomName = CITY_NAMES[Math.floor(Math.random() * CITY_NAMES.length)];
                name = randomName;
            }
            
            // Remove any existing feature
            if (tile.userData.feature) {
                gameState.scene.remove(tile.userData.feature);
            }
            
            // Create city model
            const cityGroup = new THREE.Group();
            
            // City base platform
            const platformGeometry = new THREE.CylinderGeometry(0.6, 0.7, 0.2, 8);
            const platformMaterial = new THREE.MeshPhongMaterial({
                color: team === TEAM.PLAYER ? 0x4CAF50 : 0xf44336
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.castShadow = true;
            cityGroup.add(platform);
            
            // Main building
            const buildingGeometry = new THREE.BoxGeometry(0.4, 0.5, 0.4);
            const buildingMaterial = new THREE.MeshPhongMaterial({ color: 0xE0E0E0 });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = 0.35;
            building.castShadow = true;
            cityGroup.add(building);
            
            // Tower
            const towerGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.3, 6);
            const towerMaterial = new THREE.MeshPhongMaterial({ color: 0xBDBDBD });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.set(0.2, 0.5, 0.2);
            tower.castShadow = true;
            cityGroup.add(tower);
            
            // Flag
            const flagPoleGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 4);
            const flagPoleMaterial = new THREE.MeshPhongMaterial({ color: 0x5D4037 });
            const flagPole = new THREE.Mesh(flagPoleGeometry, flagPoleMaterial);
            flagPole.position.set(0, 0.7, 0);
            cityGroup.add(flagPole);
            
            const flagGeometry = new THREE.PlaneGeometry(0.2, 0.15);
            const flagMaterial = new THREE.MeshPhongMaterial({
                color: team === TEAM.PLAYER ? 0x4CAF50 : 0xf44336,
                side: THREE.DoubleSide
            });
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(0.1, 0.8, 0);
            flag.rotation.y = Math.PI / 4;
            cityGroup.add(flag);
            
            cityGroup.position.set(x, 0.2, z);
            
            // Update tile
            tile.userData.type = 'city';
            tile.userData.feature = cityGroup;
            tile.userData.city = {
                name: name,
                team: team,
                model: cityGroup,
                population: 1,
                populationPoints: 0, // Start with 0 population points (Polytopia style)
                level: 1,
                production: name === 'Capital' ? 2 : 1, // Capital: +2 stars, others: +1 star (Polytopia rules)
                levelUpChoices: [], // Track level-up choices made
                isCapital: name === 'Capital', // Mark capital cities
                improvements: [] // Track city improvements (workshop, park, etc.)
            };
            
            // Set ownership for city and surrounding tiles (Polytopia: 3x3 starting radius)
            tile.userData.owner = team;
            const neighbors = getNeighbors(tile, 1); // Cities start with 3x3 radius (1 tile away)
            neighbors.forEach(neighbor => {
                if (neighbor.userData.type !== 'water' && !neighbor.userData.city) {
                    neighbor.userData.owner = team;
                }
            });
            
            // Change tile color
            tile.material.color.setHex(team === TEAM.PLAYER ? 0x81C784 : 0xEF5350);
            
            gameState.cities.push(tile.userData.city);
            
            // Add population display with 0 initial population
            createCityPopulationDisplay(cityGroup, 0, tile.userData.city);
            
            // Debug: Force initial population calculation
            console.log(`City created: ${tile.userData.city.name}`);
            console.log(`Initial population points: ${tile.userData.city.populationPoints}`);
            console.log(`Initial level: ${tile.userData.city.level}`);
            
            // Hide if tile is not visible
            if (!tile.visible) {
                cityGroup.visible = false;
            }
            
            gameState.scene.add(cityGroup);
        }
        
        // Update all city populations
        function updateAllCityPopulations() {
            console.log('Updating all city populations...');
            gameState.cities.forEach(city => {
                if (city && city.model) {
                    // Find the tile for this city
                    const cityTile = gameState.tiles.find(t => t.userData.city === city);
                    if (cityTile) {
                        console.log(`Updating population for city: ${city.name}`);
                        calculateCityPopulation(cityTile, true); // Skip star animation during initial setup
                    }
                }
            });
        }
        
        // Get movement cost for a tile
        function getMovementCost(tile, unit) {
            const terrain = TERRAIN_INFO[tile.userData.type];
            if (!terrain) return 999;
            
            // Base movement cost from terrain
            let cost = terrain.movementCost;
            
            // Special handling for mountains with climbing tech
            if (tile.userData.type === 'mountain' && 
                gameState.unlockedTech[unit.userData.team].includes('climbing')) {
                cost = 1; // Mountains cost 1 move with climbing (same as normal terrain)
            }
            
            // Roads reduce movement cost to 0.5 (rounds up to 1)
            if (tile.userData.improvement === 'road') {
                cost = Math.max(1, Math.floor(cost / 2));
            }
            
            return cost;
        }
        
        // Update city territory based on level (Polytopia: 3x3 borders, 5x5 vision)
        function updateCityTerritory(cityTile) {
            if (!cityTile.userData.city) return;
            
            const city = cityTile.userData.city;
            // Polytopia: cities always have 3x3 borders (radius 1), but can see 5x5 (radius 2)
            const borderRadius = 1; // Always 3x3 borders
            const visionRadius = 2; // Always 5x5 vision
            
            // Clear old territory
            const oldNeighbors = getNeighbors(cityTile, 2); // Check all possible neighbors
            oldNeighbors.forEach(neighbor => {
                if (neighbor.userData.owner === city.team && !neighbor.userData.city) {
                    neighbor.userData.owner = null;
                }
            });
            
            // Set new territory (3x3 borders)
            const newNeighbors = getNeighbors(cityTile, borderRadius);
            newNeighbors.forEach(neighbor => {
                if (neighbor.userData.type !== 'water' && !neighbor.userData.city) {
                    neighbor.userData.owner = city.team;
                }
            });
            
            // Update borders
            updateTerritoryBorders();
        }
        
        // Calculate city population based on surrounding tiles (Polytopia style)
        function calculateCityPopulation(cityTile, skipStarAnimation = false) {
            if (!cityTile.userData.city) return;
            
            const city = cityTile.userData.city;
            let populationPoints = 0; // Start with 0 population points
            
            // Count owned tiles in current city radius (Polytopia: always 3x3 borders)
            const currentRadius = 1; // Always 3x3 borders
            const neighbors = getNeighbors(cityTile, currentRadius);
            
            neighbors.forEach(neighbor => {
                if (neighbor.userData.owner === city.team) {
                    // Debug: Log tile ownership and improvements
                    console.log(`Checking tile at (${neighbor.userData.x}, ${neighbor.userData.z}):`);
                    console.log(`- Owner: ${neighbor.userData.owner}`);
                    console.log(`- Improvement: ${neighbor.userData.improvement ? neighbor.userData.improvement.type : 'none'}`);
                    console.log(`- Resource: ${neighbor.userData.resource}`);
                    console.log(`- Tile type: ${neighbor.userData.type}`);
                    
                    // Polytopia: Only improvements add population points
                    
                    // Farms add 2 population points
                    if (neighbor.userData.improvement && neighbor.userData.improvement.type === 'farm') {
                        populationPoints += 2;
                        console.log(`- Added 2 population from farm`);
                    }
                    // Mines add 2 population points  
                    else if (neighbor.userData.improvement && neighbor.userData.improvement.type === 'mine') {
                        populationPoints += 2;
                        console.log(`- Added 2 population from mine`);
                    }
                    // Lumber huts add 1 population point
                    else if (neighbor.userData.improvement && neighbor.userData.improvement.type === 'lumber_hut') {
                        populationPoints += 1;
                        console.log(`- Added 1 population from lumber hut`);
                    }
                    // Fruit resources add 1 population point (both fresh and harvested)
                    else if (neighbor.userData.resource === 'fruit' || neighbor.userData.resource === 'harvested_fruit') {
                        populationPoints += 1;
                        console.log(`- Added 1 population from fruit`);
                    } else {
                        console.log(`- No population added from this tile`);
                    }
                } else {
                    console.log(`Tile at (${neighbor.userData.x}, ${neighbor.userData.z}) not owned by ${city.team}`);
                }
            });
            
            // Update city population points
            const oldPopulationPoints = city.populationPoints || 0;
            city.populationPoints = populationPoints;
            
            // Debug: Log population calculation
            console.log(`City ${city.name} population calculation:`);
            console.log(`- Old population points: ${oldPopulationPoints}`);
            console.log(`- New population points: ${populationPoints}`);
            console.log(`- Level: ${city.level}`);
            
            // Polytopia: Cities level up when all 2 population slots are filled
            // Each level has 2 population points maximum
            const oldLevel = city.level;
            let newLevel = 1;
            
            // Level up when population points reach 2, 4, 6, 8, 10, etc.
            if (city.populationPoints >= 10) newLevel = 6;
            else if (city.populationPoints >= 8) newLevel = 5;
            else if (city.populationPoints >= 6) newLevel = 4;
            else if (city.populationPoints >= 4) newLevel = 3;
            else if (city.populationPoints >= 2) newLevel = 2;
            
            city.level = newLevel;
            
            // Debug: Log level calculation
            console.log(`Level calculation for ${city.name}:`);
            console.log(`- Population points: ${city.populationPoints}`);
            console.log(`- Old level: ${oldLevel}`);
            console.log(`- New level: ${newLevel}`);
            
            // Update city territory radius when level changes
            if (city.level !== oldLevel) {
                updateCityTerritory(cityTile);
            }
            
            // Check for level up and show choices
            // Level up choice appears when city reaches the required population for the NEW level
            // The choice should appear when the level changes (city.level > oldLevel)
            console.log(`=== LEVEL-UP CHECK ===`);
            console.log(`City: ${city.name}, Team: ${city.team}, Level: ${oldLevel} -> ${city.level}`);
            console.log(`skipStarAnimation: ${skipStarAnimation}, levelChanged: ${city.level > oldLevel}, isPlayer: ${city.team === TEAM.PLAYER}`);
            
            if (city.level > oldLevel && city.team === TEAM.PLAYER) {
                console.log(`City ${city.name} leveled up from ${oldLevel} to ${city.level}!`);
                console.log(`Population points: ${city.populationPoints}`);
                console.log(`Showing level-up choices for level ${city.level}`);
                // Show level-up menu during normal gameplay (not during end turn calculations)
                if (!skipStarAnimation) {
                    showCityLevelUpChoices(cityTile);
                } else {
                    console.log(`Level-up menu suppressed due to skipStarAnimation=true`);
                    // Queue the level-up for the next turn
                    city.pendingLevelUp = true;
                    console.log(`Queued level-up for next turn`);
                }
            } else if (city.level > oldLevel && city.team === TEAM.ENEMY) {
                console.log(`Enemy city ${city.name} leveled up from ${oldLevel} to ${city.level}!`);
                console.log(`Population points: ${city.populationPoints}`);
                // Enemy cities don't show choices, they auto-choose
            } else {
                console.log(`No level-up triggered: levelChanged=${city.level > oldLevel}, isPlayer=${city.team === TEAM.PLAYER}`);
            }
            
            // Update population display with animation if population increased
            if (populationPoints > oldPopulationPoints && !skipStarAnimation) {
                // Animate the population display update
                setTimeout(() => {
                    createCityPopulationDisplay(city.model, city.populationPoints, city);
                }, 1000); // Wait for resource flow animation to complete
            } else {
                // Immediate update for initial setup or no change
                createCityPopulationDisplay(city.model, city.populationPoints, city);
            }
            
            // Debug: Log final population display state
            console.log(`=== FINAL POPULATION DISPLAY STATE ===`);
            console.log(`City: ${city.name}`);
            console.log(`- Final population points: ${city.populationPoints}`);
            console.log(`- Final level: ${city.level}`);
            console.log(`- Skip animation: ${skipStarAnimation}`);
            
            // Level up is now automatic with choice prompt - no circle effect needed
            // The level-up choice is handled in showCityLevelUpChoices function
        }
        
        // Show city level-up choices (Polytopia style)
        function showCityLevelUpChoices(cityTile) {
            console.log('=== SHOWING LEVEL-UP CHOICES ===');
            const city = cityTile.userData.city;
            const level = city.level;
            console.log(`Creating level-up menu for ${city.name} at level ${level}`);
            
            // Polytopia level-up choices (exact Polytopia rules)
            const levelChoices = {
                2: [
                    { name: 'Workshop', icon: '‚öíÔ∏è', effect: 'workshop', description: '+1 star per turn' },
                    { name: 'Explorer', icon: 'üîç', effect: 'explorer', description: 'Reveal nearby tiles' }
                ],
                3: [
                    { name: 'City Wall', icon: 'üè∞', effect: 'city_wall', description: '+2 defense bonus' },
                    { name: 'Resources', icon: '‚≠ê', effect: 'resources', description: '+5 stars' }
                ],
                4: [
                    { name: 'Population Growth', icon: 'üë•', effect: 'population_growth', description: '+2 population points' },
                    { name: 'Border Growth', icon: 'üó∫Ô∏è', effect: 'border_growth', description: 'Expand city borders' }
                ],
                5: [
                    { name: 'Park', icon: 'üå≥', effect: 'park', description: '+1 star per turn' },
                    { name: 'Super Unit', icon: '‚öîÔ∏è', effect: 'super_unit', description: 'Build Giant unit' }
                ],
                6: [
                    { name: 'Monument', icon: 'üèõÔ∏è', effect: 'monument', description: '+10 points' },
                    { name: 'Temple', icon: '‚õ™', effect: 'temple', description: '+5 points' }
                ]
            };
            
            const choices = levelChoices[level] || levelChoices[2];
            
            // Create level-up menu
            const menu = document.createElement('div');
            menu.id = 'levelUpMenu';
            menu.style.position = 'fixed';
            menu.style.top = '50%';
            menu.style.left = '50%';
            menu.style.transform = 'translate(-50%, -50%)';
            menu.style.background = 'rgba(0,0,0,0.95)';
            menu.style.border = '3px solid #4CAF50';
            menu.style.borderRadius = '20px';
            menu.style.padding = '30px';
            menu.style.zIndex = '10000'; // Very high z-index to ensure visibility
            menu.style.color = 'white';
            menu.style.textAlign = 'center';
            menu.style.minWidth = '400px';
            menu.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.5)';
            menu.style.display = 'block';
            menu.style.visibility = 'visible';
            menu.style.opacity = '1';
            menu.style.pointerEvents = 'auto';
            
            menu.innerHTML = `
                <h2 style="margin-bottom: 20px;">${city.name} Level Up!</h2>
                <p style="margin-bottom: 20px;">Choose your city upgrade:</p>
                <div style="display: flex; gap: 20px; justify-content: center;">
                    ${choices.map((choice, index) => `
                        <div class="level-up-choice" data-choice="${index}" style="
                            background: rgba(255,255,255,0.1);
                            border: 2px solid rgba(255,255,255,0.3);
                            border-radius: 15px;
                            padding: 20px;
                            cursor: pointer;
                            transition: all 0.2s;
                            min-width: 120px;
                        ">
                            <div style="font-size: 48px; margin-bottom: 10px;">${choice.icon}</div>
                            <div style="font-weight: bold; margin-bottom: 5px;">${choice.name}</div>
                            <div style="font-size: 14px; opacity: 0.8;">${choice.description}</div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            document.body.appendChild(menu);
            
            // Add click handlers
            menu.querySelectorAll('.level-up-choice').forEach((choice, index) => {
                choice.addEventListener('click', () => {
                    console.log(`Level-up choice selected: ${choices[index].name}`);
                    applyLevelUpChoice(cityTile, choices[index]);
                    document.body.removeChild(menu);
                });
                
                choice.addEventListener('mouseenter', () => {
                    choice.style.background = 'rgba(255,255,255,0.2)';
                    choice.style.transform = 'scale(1.05)';
                });
                
                choice.addEventListener('mouseleave', () => {
                    choice.style.background = 'rgba(255,255,255,0.1)';
                    choice.style.transform = 'scale(1)';
                });
            });
            
            console.log(`Level-up menu created and added to DOM for ${city.name}`);
            console.log(`Menu element:`, menu);
            console.log(`Menu position: top: 50%, left: 50%, z-index: 9999`);
            
            // Check if menu is actually in DOM
            const menuInDOM = document.body.contains(menu);
            console.log(`Menu in DOM: ${menuInDOM}`);
            
            // Add a simple test to make the menu more visible
            menu.style.border = '5px solid #FFD700'; // Gold border
            menu.style.boxShadow = '0 0 30px rgba(255, 215, 0, 0.8)'; // Bright glow
            menu.style.background = 'rgba(0,0,0,0.98)'; // More opaque background
            
            // Check menu visibility
            setTimeout(() => {
                const menuStyle = window.getComputedStyle(menu);
                console.log(`Menu display: ${menuStyle.display}`);
                console.log(`Menu visibility: ${menuStyle.visibility}`);
                console.log(`Menu opacity: ${menuStyle.opacity}`);
                console.log(`Menu z-index: ${menuStyle.zIndex}`);
                console.log(`Menu position: ${menuStyle.position}`);
                console.log(`Menu top: ${menuStyle.top}, left: ${menuStyle.left}`);
                console.log(`Menu width: ${menuStyle.width}, height: ${menuStyle.height}`);
                console.log(`Menu background: ${menuStyle.background}`);
            }, 100);
            
            // Flash the menu to make it more visible
            menu.style.animation = 'flash 0.5s ease-in-out';
            
            // Add CSS for flash animation
            if (!document.getElementById('flash-animation')) {
                const style = document.createElement('style');
                style.id = 'flash-animation';
                style.textContent = `
                    @keyframes flash {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                        100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Apply level-up choice (Polytopia exact rules)
        function applyLevelUpChoice(cityTile, choice) {
            const city = cityTile.userData.city;
            
            switch (choice.effect) {
                case 'workshop':
                    // Add workshop improvement (+1 star per turn)
                    if (!city.improvements) city.improvements = [];
                    city.improvements.push('workshop');
                    city.production += 1; // Increase star production
                    break;
                    
                case 'explorer':
                    // Reveal more tiles around city (5x5 vision)
                    revealTiles(cityTile, 2);
                    updateEnemyVisibility();
                    break;
                    
                case 'city_wall':
                    // Add city wall (+2 defense bonus)
                    if (!city.improvements) city.improvements = [];
                    city.improvements.push('city_wall');
                    break;
                    
                case 'resources':
                    // Add 5 stars
                    gameState.stars += 5;
                    document.getElementById('stars').textContent = gameState.stars;
                    break;
                    
                case 'population_growth':
                    // Add 2 population points
                    city.populationPoints += 2;
                    break;
                    
                case 'border_growth':
                    // Expand city borders (Polytopia: cities don't expand borders, but we can implement this)
                    // For now, just add population
                    city.population += 2;
                    break;
                    
                case 'park':
                    // Add park improvement (+1 star per turn)
                    if (!city.improvements) city.improvements = [];
                    city.improvements.push('park');
                    city.production += 1; // Increase star production
                    break;
                    
                case 'super_unit':
                    // Create a giant unit
                    createUnit(cityTile.userData.x, cityTile.userData.z, 'warrior', city.team);
                    break;
                    
                case 'monument':
                    // Add monument (+10 points)
                    if (!city.improvements) city.improvements = [];
                    city.improvements.push('monument');
                    break;
                    
                case 'temple':
                    // Add temple (+5 points)
                    if (!city.improvements) city.improvements = [];
                    city.improvements.push('temple');
                    break;
            }
            
            // Record the choice
            city.levelUpChoices.push(choice.name);
            
            // Update population display
            createCityPopulationDisplay(city.model, city.populationPoints, city);
            
            // Play sound
            soundManager.play('collect');
        }
        
        // Update UI elements
        function updateUI() {
            document.getElementById('stars').textContent = gameState.stars;
            // Remove score reference since it doesn't exist
            document.getElementById('turnCount').textContent = gameState.turn;
        }
        
        // Animate star collection from city to star counter
        function animateStarCollection(cityTile, stars) {
            // Create star sprite
            const starGeometry = new THREE.PlaneGeometry(0.3, 0.3);
            const starMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < stars; i++) {
                setTimeout(() => {
                    const star = new THREE.Mesh(starGeometry, starMaterial);
                    star.position.copy(cityTile.position);
                    star.position.y = 1.5;
                    gameState.scene.add(star);
                    
                    // Animate to top left corner (star counter position)
                    const duration = 1000;
                    const startTime = Date.now();
                    
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Move towards camera/UI position
                        const targetX = -10;
                        const targetY = 10;
                        const targetZ = -5;
                        
                        star.position.x = cityTile.position.x + (targetX - cityTile.position.x) * progress;
                        star.position.y = 1.5 + (targetY - 1.5) * progress;
                        star.position.z = cityTile.position.z + (targetZ - cityTile.position.z) * progress;
                        
                        // Scale down as it approaches
                        star.scale.setScalar(1 - progress * 0.7);
                        
                        // Rotate
                        star.rotation.z = progress * Math.PI * 4;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // Remove star and add to score
                            gameState.scene.remove(star);
                            gameState.stars += 1;
                            updateUI();
                            soundManager.play('collect');
                        }
                    };
                    
                    animate();
                }, i * 200); // Stagger the animations
            }
        }
        
        // Create unit
        function createUnit(x, z, type, team) {
            const tile = gameState.tiles.find(t => t.userData.x === x && t.userData.z === z);
            if (!tile || tile.userData.type === 'water' || tile.userData.type === 'mountain' || tile.userData.isEdge) return;
            
            // Don't create if tile already has a unit (unless it's a city)
            if (tile.userData.unit && tile.userData.type !== 'city') return;
            
            const unitData = UNIT_TYPES[type];
            const unitGroup = new THREE.Group();
            
            // Smaller, flatter base
            const baseGeometry = new THREE.CylinderGeometry(0.2, 0.25, 0.1, 16);
            const baseMaterial = new THREE.MeshPhongMaterial({
                color: team === TEAM.PLAYER ? 0x4CAF50 : 0xf44336,
                emissive: team === TEAM.PLAYER ? 0x2E7D32 : 0xC62828,
                emissiveIntensity: 0.2,
                opacity: 0.8,
                transparent: true
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true;
            unitGroup.add(base);
            
            // Larger, more prominent sprite
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Add subtle shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
            
            // Transparent background ‚Äì draw composite emojis (base + overlay)
            ctx.shadowColor = 'transparent';
            // Use enemy emoji type for enemy units
            const iconString = team === TEAM.PLAYER ? unitData.icon : 
                gameState.enemyEmojiType.face + gameState.enemyEmojiType.weapon;
            const icons = Array.from(iconString);
            // Draw base emoji (e.g., face) centered (slightly smaller)
            ctx.font = 'bold 200px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (icons.length > 0) {
                ctx.fillText(icons[0], 256, 256);
            }
            // Draw overlay emoji (e.g., weapon) slightly smaller and offset top-right
            if (icons.length > 1) {
                ctx.font = 'bold 220px Arial'; // weapon slightly bigger than face
                ctx.fillText(icons[1], 390, 110); // adjust position
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                sizeAttenuation: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(1, 1, 1);
            sprite.position.y = 0.6;
            unitGroup.add(sprite);
            
            // Health bar background (always visible when damaged)
            const healthBarBg = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.08, 0.02),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            healthBarBg.position.y = 1.1;
            healthBarBg.visible = false;
            unitGroup.add(healthBarBg);
            
            // Health bar
            const healthBar = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.08, 0.02),
                new THREE.MeshBasicMaterial({ color: 0x4CAF50 })
            );
            healthBar.position.y = 1.1;
            healthBar.visible = false;
            unitGroup.add(healthBar);
            
            // Position unit above terrain features (lower emoji height)
            unitGroup.position.set(x, tile.userData.type === 'city' ? 0.5 : 0.3, z);
            
            // Store data
            unitGroup.userData = {
                type: type,
                team: team,
                tile: tile,
                hp: unitData.hp,
                maxHp: unitData.maxHp,
                attack: unitData.attack,
                defense: unitData.defense,
                movement: unitData.movement,
                movesLeft: 0, // New units cannot move on creation turn
                range: unitData.range,
                hasAttacked: false,
                hasCaptured: false, // Track if unit has captured this turn
                sprite: sprite,
                base: base,
                healthBarBg: healthBarBg,
                healthBar: healthBar
            };
            
            tile.userData.unit = unitGroup;
            gameState.units.push(unitGroup);
            gameState.scene.add(unitGroup);
        }
        
        // Update health bar
        function updateHealthBar(unit) {
            const hpPercent = unit.userData.hp / unit.userData.maxHp;
            
            if (hpPercent < 1) {
                // Show health bar
                unit.userData.healthBarBg.visible = true;
                unit.userData.healthBar.visible = true;
                
                // Update size and color
                unit.userData.healthBar.scale.x = hpPercent;
                unit.userData.healthBar.position.x = (hpPercent - 1) * 0.3;
                
                if (hpPercent > 0.6) {
                    unit.userData.healthBar.material.color.setHex(0x4CAF50);
                } else if (hpPercent > 0.3) {
                    unit.userData.healthBar.material.color.setHex(0xFFEB3B);
                } else {
                    unit.userData.healthBar.material.color.setHex(0xf44336);
                }
            } else {
                // Hide if full health
                unit.userData.healthBarBg.visible = false;
                unit.userData.healthBar.visible = false;
            }
        }
        
        // Update unit visual state
        function updateUnitVisualState(unit) {
            if (unit.userData.movesLeft === 0 || unit.userData.hasAttacked || unit.userData.hasCaptured) {
                unit.userData.sprite.material.opacity = 0.5;
                unit.userData.base.material.opacity = 0.4;
            } else {
                unit.userData.sprite.material.opacity = 1;
                unit.userData.base.material.opacity = 0.8;
            }
        }
        
        // Create combat sparks
        function createCombatSparks(position) {
            const sparks = [];
            const sparkCount = 20;
            
            for (let i = 0; i < sparkCount; i++) {
                const spark = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 4, 4),
                    new THREE.MeshPhongMaterial({ 
                        color: Math.random() > 0.5 ? 0xFFFF00 : 0xFF4444,
                        emissive: 0xFFFF00,
                        emissiveIntensity: 1
                    })
                );
                
                spark.position.copy(position);
                spark.position.y += 0.5;
                
                // Random velocity
                spark.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.3 + 0.1,
                    (Math.random() - 0.5) * 0.3
                );
                
                gameState.scene.add(spark);
                sparks.push(spark);
            }
            
            // Animate sparks
            const startTime = Date.now();
            function animateSparks() {
                const elapsed = (Date.now() - startTime) / 1000;
                
                if (elapsed > 1) {
                    // Remove sparks
                    sparks.forEach(spark => gameState.scene.remove(spark));
                    return;
                }
                
                sparks.forEach(spark => {
                    spark.position.add(spark.userData.velocity.clone().multiplyScalar(0.02));
                    spark.userData.velocity.y -= 0.01; // Gravity
                    spark.material.opacity = 1 - elapsed;
                    spark.scale.setScalar(1 - elapsed * 0.5);
                });
                
                requestAnimationFrame(animateSparks);
            }
            animateSparks();
        }
        
        // Show valid actions (only to explored tiles)
        function showValidActions(unit) {
            clearHighlights();
            if (!unit || !unit.userData || unit.userData.team !== TEAM.PLAYER) return;
            
            const unitTile = unit.userData.tile;
            if (!unitTile || !unitTile.userData) return;
            
            const unitData = unit.userData;
            
            // Show moves using movement cost calculation (cannot move if captured)
            if (unitData.movesLeft > 0 && !unitData.hasCaptured) {
                // Simple movement range calculation considering terrain costs
                const visited = new Set();
                const queue = [{tile: unitTile, cost: 0}];
                visited.add(unitTile);
                
                while (queue.length > 0) {
                    const {tile: currentTile, cost} = queue.shift();
                    
                    // Check all neighbors
                    const neighbors = getNeighbors(currentTile, 1);
                    neighbors.forEach(neighbor => {
                        if (!visited.has(neighbor) && neighbor.visible && gameState.exploredTiles.has(neighbor)) {
                            const moveCost = getMovementCost(neighbor, unit);
                            const totalCost = cost + moveCost;
                            
                            if (totalCost <= unitData.movesLeft) {
                                visited.add(neighbor);
                                
                                // Can move here if no unit or enemy city
                                if (!neighbor.userData.unit && 
                                    (!neighbor.userData.city || neighbor.userData.city.team !== unit.userData.team)) {
                                    highlightTile(neighbor, 0x4CAF50, 0.5);
                                    gameState.validMoves.push(neighbor);
                                }
                                
                                // Add to queue to check further tiles
                                queue.push({tile: neighbor, cost: totalCost});
                            }
                        }
                    });
                }
            }
            
            // Show attacks (only visible enemies)
            if (!unitData.hasAttacked) {
                const neighbors = getNeighbors(unitTile, unitData.range);
                neighbors.forEach(tile => {
                    if (tile && tile.userData && tile.visible && tile.userData.unit && 
                        tile.userData.unit.userData &&
                        tile.userData.unit.userData.team !== unit.userData.team &&
                        tile.userData.unit.visible) {
                        highlightTile(tile, 0xFF9800, 0.7); // Orange for attacks instead of red
                        gameState.validAttacks.push(tile);
                    }
                });
            }
        }
        
        // Get neighbors
        function getNeighbors(tile, range) {
            const neighbors = [];
            const x = tile.userData.x;
            const z = tile.userData.z;
            
            for (let dx = -range; dx <= range; dx++) {
                for (let dz = -range; dz <= range; dz++) {
                    if (dx === 0 && dz === 0) continue;
                    const distance = Math.max(Math.abs(dx), Math.abs(dz));
                    if (distance <= range) {
                        const neighbor = gameState.tiles.find(t => 
                            t.userData.x === x + dx && t.userData.z === z + dz
                        );
                        if (neighbor) neighbors.push(neighbor);
                    }
                }
            }
            return neighbors;
        }
        
        // Highlight tile
        function highlightTile(tile, color, opacity) {
            const indicator = tile.userData.indicator;
            if (indicator) {
                indicator.material.color.setHex(color);
                indicator.material.opacity = opacity;
                indicator.visible = true;
                gameState.tileHighlights.set(tile, indicator);
            }
        }
        
        // Clear highlights
        function clearHighlights() {
            gameState.tileHighlights.forEach(indicator => {
                indicator.visible = false;
                indicator.material.opacity = 0;
            });
            gameState.tileHighlights.clear();
            gameState.validMoves = [];
            gameState.validAttacks = [];
        }
        
        // Setup controls
        function setupControls() {
            const canvas = gameState.renderer.domElement;
            
            // Mouse/Touch events
            canvas.addEventListener('mousedown', handleInputStart);
            canvas.addEventListener('touchstart', handleInputStart, { passive: false });
            canvas.addEventListener('mousemove', handleInputMove);
            canvas.addEventListener('touchmove', handleInputMove, { passive: false });
            canvas.addEventListener('mouseup', handleInputEnd);
            canvas.addEventListener('touchend', handleInputEnd, { passive: false });
            
            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.001;
                gameState.camera.zoom = Math.max(0.3, Math.min(5, gameState.camera.zoom - e.deltaY * zoomSpeed));
                gameState.camera.updateProjectionMatrix();
            });
            
            // Middle mouse button zoom (press and drag)
            let middleMousePressed = false;
            let lastMouseY = 0;
            
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 1) { // Middle mouse button
                    e.preventDefault();
                    middleMousePressed = true;
                    lastMouseY = e.clientY;
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (middleMousePressed) {
                    const deltaY = e.clientY - lastMouseY;
                    gameState.camera.zoom = Math.max(0.3, Math.min(5, gameState.camera.zoom - deltaY * 0.005));
                    gameState.camera.updateProjectionMatrix();
                    lastMouseY = e.clientY;
                }
            });
            
            window.addEventListener('mouseup', (e) => {
                if (e.button === 1) {
                    middleMousePressed = false;
                }
            });
            
            // Buttons
            document.getElementById('endTurnBtn').addEventListener('click', endTurn);
            document.getElementById('captureBtn').addEventListener('click', () => {
                if (gameState.selectedUnit && gameState.selectedUnit.userData.team === TEAM.PLAYER) {
                    const tile = gameState.selectedUnit.userData.tile;
                    if (tile.userData.city && tile.userData.city.team !== TEAM.PLAYER) {
                        captureCity(tile, TEAM.PLAYER);
                        document.getElementById('captureBtn').style.display = 'none';
                    } else if (tile.userData.type === 'village') {
                        // Convert village to city
                        createCity(tile.userData.x, tile.userData.z, TEAM.PLAYER, 'New City');
                        

                        
                        // Update borders after capturing village
                        updateTerritoryBorders();
                        
                        // Update all city populations
                        updateAllCityPopulations();
                        
                        // Roads removed for now
                        
                        // Hide capture button
                        document.getElementById('captureBtn').style.display = 'none';
                        
                        // Play sound
                        soundManager.play('collect');
                    }
                }
            });
            document.getElementById('researchBtn').addEventListener('click', showTechTree);
            document.getElementById('testLevelUpBtn').addEventListener('click', testLevelUp);
            document.getElementById('testPopDisplayBtn').addEventListener('click', testPopulationDisplay);
            document.getElementById('testLevelUpMenuBtn').addEventListener('click', testLevelUpMenu);
            document.getElementById('testPopProgressionBtn').addEventListener('click', testPopulationProgression);
            
            document.getElementById('closeTech').addEventListener('click', () => {
                document.getElementById('techTree').style.display = 'none';
            });
            
            // Tech items
            document.querySelectorAll('.tech-item').forEach(item => {
                item.addEventListener('click', () => {
                    const tech = item.dataset.tech;
                    if (tech && canUnlockTech(tech)) {
                        unlockTech(tech);
                    }
                });
            });
            
            // Camera controls
            document.getElementById('zoomIn').addEventListener('click', () => {
                gameState.camera.zoom *= 1.2;
                gameState.camera.updateProjectionMatrix();
            });
            document.getElementById('zoomOut').addEventListener('click', () => {
                gameState.camera.zoom *= 0.8;
                gameState.camera.updateProjectionMatrix();
            });
            document.getElementById('rotateLeft').addEventListener('click', () => {
                const angle = Math.PI / 4;
                const x = gameState.camera.position.x;
                const z = gameState.camera.position.z;
                gameState.camera.position.x = x * Math.cos(angle) - z * Math.sin(angle);
                gameState.camera.position.z = x * Math.sin(angle) + z * Math.cos(angle);
                gameState.camera.lookAt(0, 0, 0);
            });
            document.getElementById('rotateRight').addEventListener('click', () => {
                const angle = -Math.PI / 4;
                const x = gameState.camera.position.x;
                const z = gameState.camera.position.z;
                gameState.camera.position.x = x * Math.cos(angle) - z * Math.sin(angle);
                gameState.camera.position.z = x * Math.sin(angle) + z * Math.cos(angle);
                gameState.camera.lookAt(0, 0, 0);
            });
            
            // Prevent city menu from closing when clicking inside it
            document.getElementById('cityMenu').addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            // Prevent improvement menu from closing when clicking inside it
            document.getElementById('improvementMenu').addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }
        
        // Show improvement menu
        function showImprovementMenu(tile) {
            const menu = document.getElementById('improvementMenu');
            const options = document.getElementById('improvementOptions');
            options.innerHTML = '';
            
            let hasOptions = false;
            
            // Always show fruit harvesting if fruit is present (Polytopia style)
            if (tile.userData.resource === 'fruit') {
                hasOptions = true;
                
                const canHarvest = gameState.unlockedTech.player.includes('harvesting');
                const card = document.createElement('div');
                card.className = 'improvement-card';
                if (!canHarvest) {
                    card.className += ' disabled';
                }
                
                card.innerHTML = `
                    <div class="improvement-icon">üçé</div>
                    <div class="improvement-name">Harvest Fruit</div>
                    <div class="improvement-cost">${canHarvest ? '+1 ‚≠ê' : 'Requires Harvesting Tech'}</div>
                `;
                
                card.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (canHarvest) {
                        harvestFruit(tile);
                    } else {
                        // Open research screen
                        document.getElementById('techTree').style.display = 'block';
                    }
                });
                
                options.appendChild(card);
            }
            
            // Lumber huts are now handled by the IMPROVEMENT_TYPES loop below
            // This removes the duplicate lumber hut option
            
            // Check available improvements for this tile
            Object.entries(IMPROVEMENT_TYPES).forEach(([type, data]) => {
                let canBuild = false;
                
                // Check if terrain matches
                if (data.validTerrain.includes(tile.userData.type) &&
                    gameState.unlockedTech.player.includes(data.tech)) {
                    
                    // Check resource requirement
                    if (data.requiresResource) {
                        // For farms, need fertile land
                        if (type === 'farm' && tile.userData.resource === true) {
                            canBuild = true;
                        }
                        // For mines, need gold deposit and climbing tech
                        else if (type === 'mine' && tile.userData.resource === true &&
                                gameState.unlockedTech.player.includes('climbing')) {
                            canBuild = true;
                        }
                    } else {
                        // No resource requirement (lumber huts)
                        canBuild = true;
                    }
                }
                
                if (canBuild) {
                    hasOptions = true;
                    
                    const card = document.createElement('div');
                    card.className = 'improvement-card';
                    if (gameState.stars < data.cost) {
                        card.className += ' disabled';
                    }
                    
                    // Get correct population value based on improvement type
                    let populationValue = 2; // Default for farms and mines
                    if (type === 'lumber_hut') {
                        populationValue = 1;
                    }
                    
                    card.innerHTML = `
                        <div class="improvement-icon">${data.icon}</div>
                        <div class="improvement-name">${type.replace('_', ' ')}</div>
                        <div class="improvement-cost">‚≠ê ${data.cost}</div>
                        <div class="improvement-production">+${populationValue} population</div>
                    `;
                    
                    card.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (gameState.stars >= data.cost) {
                            buildImprovement(tile, type);
                        }
                    });
                    
                    options.appendChild(card);
                }
            });
            
            if (hasOptions) {
                menu.style.display = 'block';
            }
        }
        
        // Build improvement
        function buildImprovement(tile, type) {
            const data = IMPROVEMENT_TYPES[type];
            if (gameState.stars < data.cost) return;
            
            // Deduct cost
            gameState.stars -= data.cost;
            document.getElementById('stars').textContent = gameState.stars;
            
            // Remove any existing features (like forests)
            if (tile.userData.feature && type !== 'lumber_hut') {
                gameState.scene.remove(tile.userData.feature);
                tile.userData.feature = null;
                
                // If it was a forest, change tile to grass (for farms)
                if (tile.userData.type === 'forest' && type === 'farm') {
                    tile.userData.type = 'grass';
                    tile.material.color.setHex(0x7CB342);
                }
            }
            
            // Create improvement
            tile.userData.improvement = {
                type: type,
                production: data.production,
                owner: TEAM.PLAYER
            };
            
            // Debug: Log improvement creation
            console.log(`Built ${type} improvement on tile at (${tile.userData.x}, ${tile.userData.z})`);
            console.log(`Improvement data:`, tile.userData.improvement);
            
            // Set tile owner
            tile.userData.owner = TEAM.PLAYER;
            
            // Debug: Log tile ownership
            console.log(`Set tile at (${tile.userData.x}, ${tile.userData.z}) owner to ${TEAM.PLAYER}`);
            
            // Create visual
            createImprovementVisual(tile, type);
            
            // Update territory borders
            updateTerritoryBorders();
            
            // Animate resource flow to nearby cities
            animateResourceFlowToCities(tile, type);
            
            // Update city populations after animation
            setTimeout(() => {
                updateAllCityPopulations();
            }, 1500);
            
            // Close menu
            document.getElementById('improvementMenu').style.display = 'none';
            
            // Play sound
            soundManager.play('move');
        }
        
        // Create improvement visual
        function createImprovementVisual(tile, type) {
            const data = IMPROVEMENT_TYPES[type];
            
            if (type === 'farm') {
                // Create farm visual
                const farmGroup = new THREE.Group();
                
                // Field rows
                for (let i = -2; i <= 2; i++) {
                    const fieldGeometry = new THREE.BoxGeometry(0.8, 0.02, 0.15);
                    const fieldMaterial = new THREE.MeshPhongMaterial({ 
                        color: i % 2 === 0 ? 0x8BC34A : 0x7CB342 
                    });
                    const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                    field.position.set(0, 0.01, i * 0.15);
                    farmGroup.add(field);
                }
                
                // Wheat sprites
                for (let i = 0; i < 6; i++) {
                    const wheatGeometry = new THREE.ConeGeometry(0.05, 0.2, 4);
                    const wheatMaterial = new THREE.MeshPhongMaterial({ color: 0xFFEB3B });
                    const wheat = new THREE.Mesh(wheatGeometry, wheatMaterial);
                    wheat.position.set(
                        (Math.random() - 0.5) * 0.6,
                        0.1,
                        (Math.random() - 0.5) * 0.6
                    );
                    wheat.rotation.y = Math.random() * Math.PI;
                    farmGroup.add(wheat);
                }
                
                farmGroup.position.copy(tile.position);
                farmGroup.position.y = 0.2;
                tile.userData.improvementVisual = farmGroup;
                gameState.scene.add(farmGroup);
                
            } else if (type === 'mine') {
                // Create mine visual
                const mineGroup = new THREE.Group();
                
                // Mine entrance
                const entranceGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.1);
                const entranceMaterial = new THREE.MeshPhongMaterial({ color: 0x424242 });
                const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
                entrance.position.set(0, 0.15, 0);
                mineGroup.add(entrance);
                
                // Dark opening
                const openingGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.05);
                const openingMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                const opening = new THREE.Mesh(openingGeometry, openingMaterial);
                opening.position.set(0, 0.15, 0.03);
                mineGroup.add(opening);
                
                // Support beams
                const beamGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.35, 4);
                const beamMaterial = new THREE.MeshPhongMaterial({ color: 0x795548 });
                const beam1 = new THREE.Mesh(beamGeometry, beamMaterial);
                beam1.position.set(-0.15, 0.175, 0);
                mineGroup.add(beam1);
                const beam2 = new THREE.Mesh(beamGeometry, beamMaterial);
                beam2.position.set(0.15, 0.175, 0);
                mineGroup.add(beam2);
                
                // Cart with gold
                const cartGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.1);
                const cartMaterial = new THREE.MeshPhongMaterial({ color: 0x5D4037 });
                const cart = new THREE.Mesh(cartGeometry, cartMaterial);
                cart.position.set(0.25, 0.05, 0.2);
                mineGroup.add(cart);
                
                // Gold in cart
                const goldGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                const goldMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFFD700,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.3
                });
                for (let i = 0; i < 3; i++) {
                    const gold = new THREE.Mesh(goldGeometry, goldMaterial);
                    gold.position.set(
                        0.25 + (Math.random() - 0.5) * 0.05,
                        0.1 + i * 0.03,
                        0.2 + (Math.random() - 0.5) * 0.05
                    );
                    mineGroup.add(gold);
                }
                
                mineGroup.position.copy(tile.position);
                mineGroup.position.y = 0.2;
                tile.userData.improvementVisual = mineGroup;
                gameState.scene.add(mineGroup);
                
            } else if (type === 'lumber_hut') {
                // Create lumber hut visual
                const hutGroup = new THREE.Group();
                
                // Hut base
                const hutGeometry = new THREE.BoxGeometry(0.3, 0.25, 0.3);
                const hutMaterial = new THREE.MeshPhongMaterial({ color: 0x8D6E63 });
                const hut = new THREE.Mesh(hutGeometry, hutMaterial);
                hut.position.y = 0.125;
                hutGroup.add(hut);
                
                // Roof
                const roofGeometry = new THREE.ConeGeometry(0.25, 0.2, 4);
                const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x5D4037 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = 0.35;
                roof.rotation.y = Math.PI / 4;
                hutGroup.add(roof);
                
                // Log pile
                const logMaterial = new THREE.MeshPhongMaterial({ color: 0x6D4C41 });
                for (let i = 0; i < 5; i++) {
                    const log = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 0.3, 6),
                        logMaterial
                    );
                    log.rotation.z = Math.PI / 2;
                    log.position.set(
                        -0.2,
                        0.03 + i * 0.03,
                        (i % 2) * 0.05 - 0.025
                    );
                    hutGroup.add(log);
                }
                
                // Axe
                const handleGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.15, 4);
                const handleMaterial = new THREE.MeshPhongMaterial({ color: 0x795548 });
                const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                handle.position.set(0.2, 0.075, 0.15);
                handle.rotation.z = -Math.PI / 6;
                hutGroup.add(handle);
                
                const bladeGeometry = new THREE.BoxGeometry(0.05, 0.08, 0.01);
                const bladeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x9E9E9E,
                    specular: 0xFFFFFF,
                    shininess: 100
                });
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.set(0.23, 0.12, 0.15);
                blade.rotation.z = -Math.PI / 6;
                hutGroup.add(blade);
                
                hutGroup.position.copy(tile.position);
                hutGroup.position.y = 0.2;
                tile.userData.improvementVisual = hutGroup;
                gameState.scene.add(hutGroup);
            }
        }
        function showTechTree() {
            updateTechTreeDisplay();
            document.getElementById('techTree').style.display = 'block';
        }
        
        // Update tech tree display
        function updateTechTreeDisplay() {
            document.querySelectorAll('.tech-item').forEach(item => {
                const tech = item.dataset.tech;
                if (gameState.unlockedTech.player.includes(tech)) {
                    item.classList.add('unlocked');
                    item.classList.remove('disabled');
                } else if (!canUnlockTech(tech)) {
                    item.classList.add('disabled');
                } else {
                    item.classList.remove('disabled', 'unlocked');
                }
            });
        }
        
        // Check if can unlock tech
        function canUnlockTech(tech) {
            if (gameState.unlockedTech.player.includes(tech)) return false;
            if (gameState.stars < TECH_COSTS[tech]) return false;
            
            // Check prerequisites
            const prerequisites = TECH_PREREQUISITES[tech] || [];
            for (const prereq of prerequisites) {
                if (!gameState.unlockedTech.player.includes(prereq)) {
                    return false;
                }
            }
            
            return true;
        }
        
        // Unlock technology
        function unlockTech(tech) {
            if (!canUnlockTech(tech)) return;
            
            // Deduct cost
            gameState.stars -= TECH_COSTS[tech];
            document.getElementById('stars').textContent = gameState.stars;
            
            // Add to unlocked
            gameState.unlockedTech.player.push(tech);
            
            // Special effects for certain techs
            if (tech === 'harvesting') {
                // Reveal fertile land on all explored tiles
                gameState.tiles.forEach(tile => {
                    if (gameState.exploredTiles.has(tile) && 
                        tile.userData.type === 'grass' && 
                        tile.userData.resource === true) {
                        // Add fertile indicator
                        if (!tile.userData.resourceIndicator) {
                            const fertileGeometry = new THREE.PlaneGeometry(0.3, 0.3);
                            const fertileMaterial = new THREE.MeshBasicMaterial({ 
                                color: 0x8BC34A,
                                transparent: true,
                                opacity: 0.6,
                                side: THREE.DoubleSide
                            });
                            const fertile = new THREE.Mesh(fertileGeometry, fertileMaterial);
                            fertile.rotation.x = -Math.PI / 2;
                            fertile.position.copy(tile.position);
                            fertile.position.y = 0.21;
                            tile.userData.resourceIndicator = fertile;
                            gameState.scene.add(fertile);
                        }
                        tile.userData.resourceIndicator.visible = true;
                    }
                });
            } else if (tech === 'climbing') {
                // Update movement costs for all units with climbing tech
                gameState.units.forEach(unit => {
                    if (unit.userData.team === TEAM.PLAYER) {
                        // Reset moves left to allow movement on mountains
                        if (unit.userData.movesLeft > 0) {
                            unit.userData.movesLeft = unit.userData.movement;
                        }
                    }
                });
                
                // Update valid moves for selected unit
                if (gameState.selectedUnit && gameState.selectedUnit.userData.team === TEAM.PLAYER) {
                    showValidActions(gameState.selectedUnit);
                }
                
                // Show notification about mountain movement and vision
                const info = document.getElementById('terrainInfo');
                document.getElementById('terrainName').textContent = 'Climbing Mastered!';
                document.getElementById('terrainDefense').textContent = '';
                document.getElementById('terrainMovement').textContent = '';
                document.getElementById('terrainFeatures').textContent = 'Units can now move on mountains for 1 movement point and see +1 square farther from mountains!';
                info.style.display = 'block';
                setTimeout(() => info.style.display = 'none', 3000);
            }
            
            // Update display
            updateTechTreeDisplay();
            
            // Play sound
            soundManager.play('move');
            
            // Show notification
            const info = document.getElementById('terrainInfo');
            document.getElementById('terrainName').textContent = 'Technology Unlocked!';
            document.getElementById('terrainDefense').textContent = '';
            document.getElementById('terrainMovement').textContent = '';
            document.getElementById('terrainFeatures').textContent = `${tech} is now available`;
            info.style.display = 'block';
            setTimeout(() => info.style.display = 'none', 2000);
        }
        
        // Handle input start
        function handleInputStart(e) {
            e.preventDefault();
            const point = e.touches ? e.touches[0] : e;
            gameState.touchStartPos = { x: point.clientX, y: point.clientY };
            gameState.lastTouchTime = Date.now();
        }
        
        // Handle input move
        function handleInputMove(e) {
            e.preventDefault();
            if (gameState.touchStartPos) {
                const point = e.touches ? e.touches[0] : e;
                const deltaX = point.clientX - gameState.touchStartPos.x;
                const deltaY = point.clientY - gameState.touchStartPos.y;
                
                if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                    gameState.isDragging = true;
                    gameState.camera.position.x -= deltaX * 0.02;
                    gameState.camera.position.z -= deltaY * 0.02;
                    gameState.touchStartPos = { x: point.clientX, y: point.clientY };
                }
            }
        }
        
        // Handle input end
        function handleInputEnd(e) {
            e.preventDefault();
            if (!gameState.isDragging && Date.now() - gameState.lastTouchTime < 300) {
                handleTap(gameState.touchStartPos);
            }
            gameState.isDragging = false;
            gameState.touchStartPos = null;
        }
        
        // Handle tap
        function handleTap(position) {
            const mouse = new THREE.Vector2();
            mouse.x = (position.x / window.innerWidth) * 2 - 1;
            mouse.y = -(position.y / window.innerHeight) * 2 + 1;
            
            gameState.raycaster.setFromCamera(mouse, gameState.camera);
            
            // Check units first (for emoji clicking)
            const visibleUnits = gameState.units.filter(u => u.visible);
            const unitIntersects = gameState.raycaster.intersectObjects(visibleUnits, true);
            if (unitIntersects.length > 0) {
                // Find the unit that was clicked
                let clickedUnit = null;
                for (const intersect of unitIntersects) {
                    let obj = intersect.object;
                    while (obj && !obj.userData.type) {
                        obj = obj.parent;
                    }
                    if (obj && obj.userData.type) {
                        clickedUnit = obj;
                        break;
                    }
                }
                
                if (clickedUnit) {
                    selectUnit(clickedUnit);
                    return;
                }
            }
            
            // Check only visible tiles
            const visibleTiles = gameState.tiles.filter(t => t.visible);
            const intersects = gameState.raycaster.intersectObjects(visibleTiles);
            if (intersects.length > 0) {
                const tile = intersects[0].object;
                handleTileSelection(tile);
            }
        }
        
        // Handle tile selection
        function handleTileSelection(tile) {
            // Ignore edge tiles
            if (tile.userData.isEdge) return;
            
            // Close menus if open
            if (document.getElementById('cityMenu').style.display === 'block' && 
                (!tile.userData.city || tile.userData.city !== gameState.selectedCity)) {
                document.getElementById('cityMenu').style.display = 'none';
                gameState.selectedCity = null;
            }
            
            if (document.getElementById('improvementMenu').style.display === 'block') {
                document.getElementById('improvementMenu').style.display = 'none';
            }
            
            // If tile has a unit
            if (tile.userData.unit) {
                // If it's a valid attack target
                if (gameState.selectedUnit && 
                    gameState.selectedUnit.userData.team === TEAM.PLAYER &&
                    gameState.validAttacks.includes(tile)) {
                    executeAttack(tile);
                    return;
                }
                
                // Check if we're tapping the same unit again
                if (gameState.selectedUnit === tile.userData.unit) {
                    // Second tap on same unit - show ground info instead
                    if (tile.userData.city) {
                        showCityMenu(tile);
                    } else if (gameState.exploredTiles.has(tile)) {
                        showTerrainInfo(tile);
                    }
                    return;
                }
                
                // Otherwise select the unit
                selectUnit(tile.userData.unit);
                return;
            }
            
            // If tile has a city and it's our turn and our city
            if (tile.userData.city && 
                tile.userData.city.team === TEAM.PLAYER && 
                gameState.currentTeam === TEAM.PLAYER) {
                showCityMenu(tile);
                return;
            }
            
            // If we have a selected unit
            if (gameState.selectedUnit && gameState.selectedUnit.userData.team === TEAM.PLAYER) {
                // Check if it's a valid move
                if (gameState.validMoves.includes(tile)) {
                    moveUnit(gameState.selectedUnit, tile);
                    return;
                }
            }
            
            // Check if we can build improvements on this tile (Polytopia: always show options)
            if (gameState.currentTeam === TEAM.PLAYER && 
                !tile.userData.improvement && 
                !tile.userData.city &&
                gameState.exploredTiles.has(tile)) {
                
                // Always show improvement menu for fruit and forests (Polytopia style)
                if ((tile.userData.type === 'grass' && tile.userData.resource === 'fruit') ||
                    (tile.userData.type === 'forest')) {
                    showImprovementMenu(tile);
                    return;
                }
                
                // Check if we have the necessary tech for other improvements
                let canBuild = false;
                
                // Check for farms on fertile land
                if (tile.userData.type === 'grass' && tile.userData.resource === true &&
                    gameState.unlockedTech.player.includes('farming')) {
                    canBuild = true;
                }
                
                // Check for mines on gold mountains (need climbing too)
                if (tile.userData.type === 'mountain' && tile.userData.resource === true &&
                    gameState.unlockedTech.player.includes('mining') &&
                    gameState.unlockedTech.player.includes('climbing')) {
                    canBuild = true;
                }
                
                if (canBuild) {
                    showImprovementMenu(tile);
                    return;
                }
            }
            
            // Otherwise show terrain info (only if explored)
            if (gameState.exploredTiles.has(tile)) {
                showTerrainInfo(tile);
            }
            
            // Deselect unit if selected
            if (gameState.selectedUnit) {
                deselectUnit();
            }
        }
        
        // Show terrain info
        function showTerrainInfo(tile) {
            const info = TERRAIN_INFO[tile.userData.type] || TERRAIN_INFO.grass;
            
            let terrainName = info.name;
            
            // Special handling for cities
            if (tile.userData.city) {
                const city = tile.userData.city;
                terrainName = `${city.name} (Level ${city.level})`;
                document.getElementById('terrainName').textContent = terrainName;
                document.getElementById('terrainDefense').textContent = `+${info.defense}`;
                document.getElementById('terrainMovement').textContent = info.movementCost;
                
                let features = `Population: ${city.populationPoints} | `;
                features += `Production: +${city.production} ‚≠ê/turn | `;
                features += `Owner: ${city.team}`;
                document.getElementById('terrainFeatures').textContent = features;
            } else {
                // Normal terrain handling
                // Show resource info if applicable
                if (tile.userData.resource === true) {
                    if (tile.userData.type === 'grass' && gameState.unlockedTech.player.includes('harvesting')) {
                        terrainName += ' (Fertile)';
                    } else if (tile.userData.type === 'mountain') {
                        terrainName += ' (Gold Deposit)';
                    }
                } else if (tile.userData.resource === 'fruit') {
                    terrainName += ' (Fruit)';
                }
                
                document.getElementById('terrainName').textContent = terrainName;
                document.getElementById('terrainDefense').textContent = `+${info.defense}`;
                
                let movementText = info.movementCost === 999 ? 'Impassable' : info.movementCost;
                if (tile.userData.type === 'mountain' && gameState.unlockedTech.player.includes('climbing')) {
                    movementText = '1';
                }
                document.getElementById('terrainMovement').textContent = movementText;
                
                let features = info.features;
                if (tile.userData.type === 'mountain' && !gameState.unlockedTech.player.includes('climbing')) {
                    features = 'Requires climbing tech to traverse';
                }
                if (tile.userData.improvement) {
                    const impType = tile.userData.improvement.type;
                    const impData = IMPROVEMENT_TYPES[impType];
                    features += ` | ${impData.icon} ${impType.replace('_', ' ')} (+2 population)`;
                }
                if (tile.userData.owner) {
                    features += ` | Territory: ${tile.userData.owner}`;
                }
                document.getElementById('terrainFeatures').textContent = features;
            }
            
            document.getElementById('terrainInfo').style.display = 'block';
            
            // Hide after 3 seconds
            setTimeout(() => {
                document.getElementById('terrainInfo').style.display = 'none';
            }, 3000);
        }
        
        // Show city menu
        function showCityMenu(tile) {
            gameState.selectedCity = tile.userData.city;
            document.getElementById('cityTitle').textContent = tile.userData.city.name;
            
            // Clear and populate unit shop
            const unitShop = document.getElementById('unitShop');
            unitShop.innerHTML = '';
            
            // Add available units
            Object.entries(UNIT_TYPES).forEach(([type, data]) => {
                if (data.tech === null || gameState.unlockedTech.player.includes(data.tech)) {
                    const card = document.createElement('div');
                    card.className = 'unit-card';
                    if (gameState.stars < data.cost) {
                        card.className += ' disabled';
                    }
                    
                    card.innerHTML = `
                        <div class="unit-card-icon">${data.icon}</div>
                        <div class="unit-card-name">${type}</div>
                        <div class="unit-card-cost">‚≠ê ${data.cost}</div>
                        <div style="font-size: 10px; color: #ccc;">‚öîÔ∏è${data.attack} üõ°Ô∏è${data.defense} üëü${data.movement}</div>
                    `;
                    
                    card.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (gameState.stars >= data.cost && !tile.userData.unit) {
                            produceUnit(tile, type);
                        }
                    });
                    
                    unitShop.appendChild(card);
                }
            });
            
            document.getElementById('cityMenu').style.display = 'block';
        }
        
        // Produce unit from city
        function produceUnit(cityTile, unitType) {
            const unitData = UNIT_TYPES[unitType];
            if (gameState.stars < unitData.cost || cityTile.userData.unit) return;
            
            // Deduct cost
            gameState.stars -= unitData.cost;
            document.getElementById('stars').textContent = gameState.stars;
            
            // Create unit
            createUnit(cityTile.userData.x, cityTile.userData.z, unitType, TEAM.PLAYER);
            
            // Reveal area around new unit (cities have 5x5 vision)
            revealTiles(cityTile, 2);
            updateEnemyVisibility();
            
            // Close menu
            document.getElementById('cityMenu').style.display = 'none';
            gameState.selectedCity = null;
            
            // Play sound
            soundManager.play('move');
        }
        
        // Select unit
        function selectUnit(unit) {
            if (gameState.selectedUnit) {
                gameState.selectedUnit.userData.base.material.emissiveIntensity = 0.2;
            }
            
            clearHighlights();
            gameState.selectedUnit = unit;
            unit.userData.base.material.emissiveIntensity = 0.5;
            
            showValidActions(unit);
            
            // Update UI
            document.getElementById('bottomUI').style.display = 'flex';
            document.getElementById('unitName').textContent = unit.userData.type.charAt(0).toUpperCase() + unit.userData.type.slice(1);
            document.getElementById('unitIcon').textContent = UNIT_TYPES[unit.userData.type].icon;
            document.getElementById('unitHP').textContent = `${unit.userData.hp}/${unit.userData.maxHp}`;
            document.getElementById('unitATK').textContent = unit.userData.attack;
            document.getElementById('unitDEF').textContent = unit.userData.defense;
            document.getElementById('unitMoves').textContent = unit.userData.movesLeft;
            document.getElementById('hpFill').style.width = `${(unit.userData.hp / unit.userData.maxHp) * 100}%`;
            
            // Show capture button if unit is on enemy city or village and hasn't captured this turn
            const tile = unit.userData.tile;
            if (!unit.userData.hasCaptured && 
                ((tile.userData.city && tile.userData.city.team !== unit.userData.team &&
                unit.userData.team === TEAM.PLAYER) ||
                (tile.userData.type === 'village' && unit.userData.team === TEAM.PLAYER))) {
                document.getElementById('captureBtn').style.display = 'flex';
            } else {
                document.getElementById('captureBtn').style.display = 'none';
            }
        }
        
        // Deselect unit
        function deselectUnit() {
            if (gameState.selectedUnit) {
                gameState.selectedUnit.userData.base.material.emissiveIntensity = 0.2;
                gameState.selectedUnit = null;
                clearHighlights();
                document.getElementById('bottomUI').style.display = 'none';
                document.getElementById('captureBtn').style.display = 'none';
            }
        }
        
        // Move unit
        function moveUnit(unit, targetTile) {
            if (gameState.isAnimating) return;
            gameState.isAnimating = true;
            
            unit.userData.tile.userData.unit = null;
            unit.userData.tile = targetTile;
            targetTile.userData.unit = unit;
            
            // Calculate actual movement cost
            const moveCost = getMovementCost(targetTile, unit);
            unit.userData.movesLeft = 0; // one move per turn
            
            // Animate
            const start = unit.position.clone();
            const end = new THREE.Vector3(targetTile.position.x, 0.4, targetTile.position.z);
            const startTime = Date.now();
            
            function animate() {
                const progress = Math.min((Date.now() - startTime) / 500, 1);
                unit.position.lerpVectors(start, end, progress);
                unit.position.y = 0.4 + Math.sin(progress * Math.PI) * 0.2;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    gameState.isAnimating = false;
                    soundManager.play('move');
                    
                    // Update visual state
                    updateUnitVisualState(unit);
                    
                    // Reveal tiles around new position
                    if (unit.userData.team === TEAM.PLAYER) {
                        revealTiles(targetTile, 1);
                        updateEnemyVisibility();
                    }
                    
                    if (gameState.selectedUnit === unit) {
                        document.getElementById('unitMoves').textContent = unit.userData.movesLeft;
                        
                        // Update capture button visibility
                        const tile = unit.userData.tile;
                        if (!unit.userData.hasCaptured && 
                            ((tile.userData.city && tile.userData.city.team !== unit.userData.team &&
                            unit.userData.team === TEAM.PLAYER) ||
                            (tile.userData.type === 'village' && unit.userData.team === TEAM.PLAYER))) {
                            document.getElementById('captureBtn').style.display = 'flex';
                        } else {
                            document.getElementById('captureBtn').style.display = 'none';
                        }
                    }
                    
                    // Check for captures and attacks after moving
                    checkForCaptures(unit);
                    
                    // Then check for possible attacks
                    if (!unit.userData.hasAttacked && gameState.selectedUnit === unit) {
                        const neighbors = getNeighbors(unit.userData.tile, unit.userData.range);
                        const hasEnemies = neighbors.some(tile => 
                            tile && tile.userData && tile.userData.unit && 
                            tile.userData.unit.userData &&
                            tile.userData.unit.userData.team !== unit.userData.team
                        );
                        
                        if (hasEnemies) {
                            setTimeout(() => showValidActions(unit), 100);
                        }
                    }
                }
            }
            animate();
            
            // Add helper to check if all player units have moved and update button state
            checkAllUnitsMoved();
            selectNextUnmovedUnit();
        }
        
        // Check for captures when unit moves
        function checkForCaptures(unit) {
            const tile = unit.userData.tile;
            
            // Check if we're on an enemy city or village
            if ((tile.userData.city && tile.userData.city.team !== unit.userData.team) ||
                (tile.userData.type === 'village' && unit.userData.team === TEAM.PLAYER)) {
                // Don't auto-capture cities - require explicit action in Polytopia style
                // This will be handled by a separate capture action
            }
        }
        
        // Capture city with confirmation
        function captureCity(tile, newTeam) {
            if (!tile || !tile.userData || !tile.userData.city) return;
            
            const city = tile.userData.city;
            const oldTeam = city.team;
            if (oldTeam === newTeam) return;
            
            // Show capture confirmation
            const confirmCapture = () => {
                city.team = newTeam;
                
                // Update city appearance
                if (tile.material) {
                    tile.material.color.setHex(newTeam === TEAM.PLAYER ? 0x81C784 : 0xEF5350);
                }
                
                // Update flag color
                if (city.model && city.model.children) {
                    const flag = city.model.children.find(child => 
                        child.geometry && child.geometry.type === 'PlaneGeometry'
                    );
                    if (flag && flag.material) {
                        flag.material.color.setHex(newTeam === TEAM.PLAYER ? 0x4CAF50 : 0xf44336);
                    }
                    
                    // Update platform color
                    const platform = city.model.children[0];
                    if (platform && platform.material) {
                        platform.material.color.setHex(newTeam === TEAM.PLAYER ? 0x4CAF50 : 0xf44336);
                    }
                }
                
                // Update tile ownership and surrounding tiles (Polytopia: 3x3 starting radius)
                tile.userData.owner = newTeam;
                const neighbors = getNeighbors(tile, 1); // Cities start with 3x3 radius (1 tile away)
                neighbors.forEach(neighbor => {
                    if (neighbor.userData.type !== 'water' && !neighbor.userData.city) {
                        neighbor.userData.owner = newTeam;
                    }
                });
                
                // Update borders
                updateTerritoryBorders();
                
                // Update city population
                calculateCityPopulation(tile);
                
                // Roads removed for now
                

                
                // Reveal area around captured city if player captured it (cities have 5x5 vision)
                if (newTeam === TEAM.PLAYER) {
                    revealTiles(tile, 2);
                    updateEnemyVisibility();
                }
                
                // Show notification
                const info = document.getElementById('terrainInfo');
                if (info) {
                    document.getElementById('terrainName').textContent = 'City Captured!';
                    document.getElementById('terrainDefense').textContent = '';
                    document.getElementById('terrainMovement').textContent = '';
                    document.getElementById('terrainFeatures').textContent = `${city.name} is now ${newTeam === TEAM.PLAYER ? 'yours' : 'enemy controlled'}!`;
                    info.style.display = 'block';
                    setTimeout(() => info.style.display = 'none', 2000);
                }
                
                // Mark unit as having captured this turn and disable movement
                if (gameState.selectedUnit) {
                    gameState.selectedUnit.userData.hasCaptured = true;
                    gameState.selectedUnit.userData.movesLeft = 0; // Cannot move after capture
                    updateUnitVisualState(gameState.selectedUnit);
                    
                    // Clear valid moves since unit can no longer move
                    clearHighlights();
                    
                    // Update UI
                    if (gameState.selectedUnit === gameState.selectedUnit) {
                        document.getElementById('unitMoves').textContent = gameState.selectedUnit.userData.movesLeft;
                    }
                }
                
                // Play capture sound
                soundManager.play('move');
                
                // Hide capture button
                document.getElementById('captureBtn').style.display = 'none';
            };
            
            // Show confirmation dialog
            if (confirm(`Capture ${city.name}? This will take 1 turn.`)) {
                confirmCapture();
            }
        }
        
        // Execute attack on tile
        function executeAttack(tile) {
            const target = tile.userData.unit;
            if (!target || !gameState.selectedUnit || gameState.isAnimating) return;
            
            gameState.isAnimating = true;
            const attacker = gameState.selectedUnit;
            
            // Animate attack
            const originalPos = attacker.position.clone();
            const direction = new THREE.Vector3().subVectors(target.position, originalPos).normalize();
            const attackPos = originalPos.clone().add(direction.multiplyScalar(0.3));
            
            // Move towards target
            const moveTime = 200;
            const startTime = Date.now();
            
            function animateAttack() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / moveTime, 1);
                
                if (progress < 1) {
                    attacker.position.lerpVectors(originalPos, attackPos, progress);
                    requestAnimationFrame(animateAttack);
                } else {
                    // Hit moment - create sparks
                    createCombatSparks(target.position);
                    soundManager.play('attack');
                    
                    // Screen shake
                    const camPos = gameState.camera.position.clone();
                    gameState.camera.position.x += (Math.random() - 0.5) * 0.3;
                    gameState.camera.position.z += (Math.random() - 0.5) * 0.3;
                    setTimeout(() => gameState.camera.position.copy(camPos), 100);
                    
                    // Get terrain defense bonus
                    const targetTerrain = TERRAIN_INFO[target.userData.tile.userData.type] || TERRAIN_INFO.grass;
                    const defenseBonus = targetTerrain.defense;
                    
                    // Calculate damage with terrain bonus
                    const damage = Math.max(1, attacker.userData.attack - (target.userData.defense + defenseBonus) + 2);
                    target.userData.hp -= damage;
                    
                    // Counter damage if defender survives
                    let counterDamage = 0;
                    if (target.userData.hp > 0) {
                        // Defender strikes back!
                        counterDamage = Math.max(1, target.userData.attack - attacker.userData.defense);
                        attacker.userData.hp -= counterDamage;
                        
                        // Visual feedback for counter attack
                        setTimeout(() => {
                            createCombatSparks(attacker.position);
                        }, 150);
                    }
                    
                    // Update health bars
                    updateHealthBar(attacker);
                    updateHealthBar(target);
                    
                    // Move back
                    setTimeout(() => {
                        const backTime = Date.now();
                        function animateBack() {
                            const backProgress = Math.min((Date.now() - backTime) / 200, 1);
                            attacker.position.lerpVectors(attackPos, originalPos, backProgress);
                            
                            if (backProgress < 1) {
                                requestAnimationFrame(animateBack);
                            } else {
                                // Update states
                                attacker.userData.hasAttacked = true;
                                attacker.userData.movesLeft = 0;
                                
                                // Update visual states
                                updateUnitVisualState(attacker);
                                if (target.userData.hp > 0) {
                                    updateUnitVisualState(target);
                                }
                                
                                // Remove dead units
                                if (target.userData.hp <= 0) {
                                    removeUnit(target);
                                }
                                if (attacker.userData.hp <= 0) {
                                    removeUnit(attacker);
                                } else {
                                    showValidActions(attacker);
                                }
                                
                                // Update UI
                                if (gameState.selectedUnit && gameState.selectedUnit.userData) {
                                    document.getElementById('unitHP').textContent = 
                                        `${attacker.userData.hp}/${attacker.userData.maxHp}`;
                                    document.getElementById('unitMoves').textContent = attacker.userData.movesLeft;
                                    document.getElementById('hpFill').style.width = 
                                        `${(attacker.userData.hp / attacker.userData.maxHp) * 100}%`;
                                    
                                    // Check if unit is now on enemy city after defeating defender
                                    if (target.userData.hp <= 0) {
                                        const tile = attacker.userData.tile;
                                        if (!attacker.userData.hasCaptured && 
                                            tile.userData.city && tile.userData.city.team !== attacker.userData.team &&
                                            attacker.userData.team === TEAM.PLAYER) {
                                            document.getElementById('captureBtn').style.display = 'flex';
                                        }
                                    }
                                }
                                
                                gameState.isAnimating = false;
                                checkWinCondition();
                            }
                        }
                        animateBack();
                    }, 300);
                }
            }
            animateAttack();
        }
        
        // Check win condition
        function checkWinCondition() {
            const playerUnits = gameState.units.filter(u => u.userData.team === TEAM.PLAYER);
            const enemyUnits = gameState.units.filter(u => u.userData.team === TEAM.ENEMY);
            const playerCities = gameState.cities.filter(c => c.team === TEAM.PLAYER);
            const enemyCities = gameState.cities.filter(c => c.team === TEAM.ENEMY);
            
            if (playerUnits.length === 0 && playerCities.length === 0) {
                setTimeout(() => {
                    alert('Game Over! The enemy has conquered your civilization.');
                    location.reload();
                }, 1000);
                            } else if (enemyUnits.length === 0 && enemyCities.length === 0) {
                setTimeout(() => {
                    alert(`Victory! You conquered all enemy tribes in ${gameState.turn} turns!`);
                    location.reload();
                }, 1000);
            }
        }
        
        // Remove unit
        function removeUnit(unit) {
            unit.userData.tile.userData.unit = null;
            gameState.scene.remove(unit);
            const index = gameState.units.indexOf(unit);
            if (index > -1) gameState.units.splice(index, 1);
            
            if (unit === gameState.selectedUnit) {
                deselectUnit();
            }
            
            // Update visibility immediately after unit removal
            if (unit.userData.team === TEAM.ENEMY) {
                updateEnemyVisibility();
            }
        }
        
        // End turn
        function endTurn() {
            clearHighlights();
            deselectUnit();
            
            // Hide menus if open
            document.getElementById('cityMenu').style.display = 'none';
            document.getElementById('improvementMenu').style.display = 'none';
            
            if (gameState.currentTeam === TEAM.PLAYER) {
                gameState.currentTeam = TEAM.ENEMY;
                document.getElementById('turnIndicator').textContent = 'Enemy Turn';
                document.getElementById('turnIndicator').className = 'turn-indicator enemy-turn';
                runAI();
            } else {
                gameState.turn++;
                gameState.currentTeam = TEAM.PLAYER;
                document.getElementById('turnIndicator').textContent = 'Player Turn';
                document.getElementById('turnIndicator').className = 'turn-indicator player-turn';
                document.getElementById('turnCount').textContent = gameState.turn;
                
                // Reset player units
                gameState.units.forEach(unit => {
                    if (unit.userData.team === TEAM.PLAYER) {
                        unit.userData.movesLeft = unit.userData.movement;
                        unit.userData.hasAttacked = false;
                        unit.userData.hasCaptured = false;
                        updateUnitVisualState(unit);
                    }
                });
                
                // Collect stars from cities (Polytopia: 1 star per city level + bonuses)
                const playerCities = gameState.cities.filter(c => c.team === TEAM.PLAYER);
                let cityIncome = 0;
                playerCities.forEach(city => {
                    const cityTile = gameState.tiles.find(t => t.userData.city === city);
                    if (cityTile) {
                        // Recalculate population first (skip level up animation during end turn)
                        calculateCityPopulation(cityTile, true);
                        
                        // Base stars: 1 per city level (Polytopia rule)
                        let starsGenerated = city.level;
                        
                        // Workshop bonus: +1 star per turn
                        if (city.improvements && city.improvements.includes('workshop')) {
                            starsGenerated += 1;
                        }
                        
                        // Park bonus: +1 star per turn
                        if (city.improvements && city.improvements.includes('park')) {
                            starsGenerated += 1;
                        }
                        
                        // Capital bonus: +1 star for human player capitals
                        if (city.isCapital) {
                            starsGenerated += 1;
                        }
                        
                        // Monument and temple don't generate stars, they generate points
                        
                        cityIncome += starsGenerated;
                        animateStarCollection(cityTile, starsGenerated);
                    }
                });
                
                // Improvements don't produce stars in Polytopia - only cities and special buildings do
                
                document.getElementById('stars').textContent = gameState.stars;
                
                // Cap stars at reasonable maximum
                if (gameState.stars > 99) {
                    gameState.stars = 99;
                    document.getElementById('stars').textContent = gameState.stars;
                }
                
                // Show income summary if there's any income
                if (cityIncome > 0) {
                    const info = document.getElementById('terrainInfo');
                    document.getElementById('terrainName').textContent = 'Income Summary';
                    document.getElementById('terrainDefense').textContent = '';
                    document.getElementById('terrainMovement').textContent = '';
                    const popTotal = playerCities.reduce((sum, city) => {
                        const tile = gameState.tiles.find(t => t.userData.city === city);
                        return sum + (tile ? tile.userData.city.populationPoints : 0);
                    }, 0);
                    const incomeText = `+${cityIncome} ‚≠ê from cities (${playerCities.length}, Pop ${popTotal})`;
                    document.getElementById('terrainFeatures').textContent = incomeText;
                    info.style.display = 'block';
                    setTimeout(() => info.style.display = 'none', 3000);
                }
                
                // Check for pending level-ups at start of player turn
                gameState.cities.forEach(city => {
                    if (city.team === TEAM.PLAYER && city.pendingLevelUp) {
                        console.log(`Processing pending level-up for ${city.name}`);
                        const cityTile = gameState.tiles.find(t => t.userData.city === city);
                        if (cityTile) {
                            showCityLevelUpChoices(cityTile);
                        }
                        city.pendingLevelUp = false;
                    }
                });
                
                // Update visibility
                updateEnemyVisibility();
            }
            
            // Add helper to check if all player units have moved and update button state
            checkAllUnitsMoved();
        }
        
        // Simple AI
        function runAI() {
            setTimeout(() => {
                // Reset enemy units
                gameState.units.forEach(unit => {
                    if (unit.userData.team === TEAM.ENEMY) {
                        unit.userData.movesLeft = unit.userData.movement;
                        unit.userData.hasAttacked = false;
                        unit.userData.hasCaptured = false;
                        updateUnitVisualState(unit);
                    }
                });
                
                // Move and attack with each enemy unit
                const enemyUnits = gameState.units.filter(u => u.userData.team === TEAM.ENEMY);
                let actionIndex = 0;
                
                function processNextUnit() {
                    if (actionIndex >= enemyUnits.length) {
                        endTurn();
                        return;
                    }
                    
                    const unit = enemyUnits[actionIndex];
                    actionIndex++;
                    
                    // Find nearest visible player unit
                    const playerUnits = gameState.units.filter(u => u.userData.team === TEAM.PLAYER);
                    if (playerUnits.length === 0) {
                        processNextUnit();
                        return;
                    }
                    
                    // AI can see within 2 tiles of their units and cities
                    const visiblePlayerUnits = playerUnits.filter(playerUnit => {
                        // Check if any enemy unit can see this player unit
                        let canSee = false;
                        
                        gameState.units.forEach(enemyUnit => {
                            if (enemyUnit.userData.team === TEAM.ENEMY) {
                                const dist = Math.abs(playerUnit.userData.tile.userData.x - enemyUnit.userData.tile.userData.x) +
                                           Math.abs(playerUnit.userData.tile.userData.z - enemyUnit.userData.tile.userData.z);
                                if (dist <= 2) canSee = true;
                            }
                        });
                        
                        // Check if any enemy city can see this player unit
                        gameState.cities.forEach(city => {
                            if (city.team === TEAM.ENEMY) {
                                const cityTile = gameState.tiles.find(t => t.userData.city === city);
                                if (cityTile) {
                                    const dist = Math.abs(playerUnit.userData.tile.userData.x - cityTile.userData.x) +
                                               Math.abs(playerUnit.userData.tile.userData.z - cityTile.userData.z);
                                    if (dist <= 2) canSee = true;
                                }
                            }
                        });
                        
                        return canSee;
                    });
                    
                    if (visiblePlayerUnits.length === 0) {
                        processNextUnit();
                        return;
                    }
                    
                    let nearestPlayer = null;
                    let minDist = Infinity;
                    
                    visiblePlayerUnits.forEach(player => {
                        const dist = Math.abs(unit.userData.tile.userData.x - player.userData.tile.userData.x) +
                                   Math.abs(unit.userData.tile.userData.z - player.userData.tile.userData.z);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestPlayer = player;
                        }
                    });
                    
                    // Check if can attack
                    const attackNeighbors = getNeighbors(unit.userData.tile, unit.userData.range);
                    const canAttack = attackNeighbors.find(t => t.userData.unit === nearestPlayer);
                    
                    if (canAttack) {
                        // Attack
                        selectUnit(unit);
                        setTimeout(() => {
                            gameState.validAttacks.push(canAttack);
                            executeAttack(canAttack);
                            setTimeout(processNextUnit, 1000);
                        }, 500);
                    } else if (unit.userData.movesLeft > 0 && !unit.userData.hasCaptured) {
                        // Move towards player
                        const moveNeighbors = getNeighbors(unit.userData.tile, 1);
                        let bestMove = null;
                        let bestDist = minDist;
                        
                        moveNeighbors.forEach(tile => {
                            if (tile.userData.type !== 'water' && !tile.userData.unit) {
                                // Check mountain accessibility for AI
                                if (tile.userData.type === 'mountain' && 
                                    !gameState.unlockedTech.enemy.includes('climbing')) {
                                    return; // Can't move to mountains without climbing
                                }
                                
                                const dist = Math.abs(tile.userData.x - nearestPlayer.userData.tile.userData.x) +
                                           Math.abs(tile.userData.z - nearestPlayer.userData.tile.userData.z);
                                if (dist < bestDist) {
                                    bestDist = dist;
                                    bestMove = tile;
                                }
                            }
                        });
                        
                        if (bestMove) {
                            selectUnit(unit);
                            setTimeout(() => {
                                moveUnit(unit, bestMove);
                                setTimeout(() => {
                                    // Check for captures after AI moves
                                    checkForCaptures(unit);
                                    
                                    // Check if AI can capture a city
                                    const tile = unit.userData.tile;
                                    if (tile.userData.city && tile.userData.city.team !== TEAM.ENEMY) {
                                        captureCity(tile, TEAM.ENEMY);
                                        // Mark AI unit as having captured and disable movement
                                        unit.userData.hasCaptured = true;
                                        unit.userData.movesLeft = 0; // Cannot move after capture
                                        updateUnitVisualState(unit);
                                    }
                                    
                                    processNextUnit();
                                }, 1000);
                            }, 500);
                        } else {
                            processNextUnit();
                        }
                    } else {
                        processNextUnit();
                    }
                }
                
                // Also have AI produce units from cities
                const enemyCities = gameState.cities.filter(c => c.team === TEAM.ENEMY);
                enemyCities.forEach(city => {
                    const cityTile = gameState.tiles.find(t => t.userData.city === city);
                    if (cityTile && !cityTile.userData.unit) {
                        // Simple AI: produce warriors or archers
                        const unitType = gameState.unlockedTech.enemy.includes('archery') && Math.random() > 0.5 ? 'archer' : 'warrior';
                        createUnit(cityTile.userData.x, cityTile.userData.z, unitType, TEAM.ENEMY);
                    }
                });
                
                // AI tries to build improvements on some tiles
                if (Math.random() < 0.3) { // 30% chance to try building
                    const enemyTiles = gameState.tiles.filter(t => 
                        t.userData.owner === TEAM.ENEMY && 
                        !t.userData.improvement &&
                        !t.userData.city
                    );
                    
                    if (enemyTiles.length > 0) {
                        const randomTile = enemyTiles[Math.floor(Math.random() * enemyTiles.length)];
                        
                        // Try to build appropriate improvement
                        if (randomTile.userData.type === 'forest' && gameState.unlockedTech.enemy.includes('forestry')) {
                            randomTile.userData.improvement = {
                                type: 'lumber_hut',
                                production: 1,
                                owner: TEAM.ENEMY
                            };
                            createImprovementVisual(randomTile, 'lumber_hut');
                        }
                    }
                }
                
                processNextUnit();
            }, 1000);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            gameState.renderer.render(gameState.scene, gameState.camera);
        }
        
        // Initialize
        window.addEventListener('load', () => {
            initScene();
            setupControls();
            animate();
            
            // Initialize all unit visual states and visibility
            setTimeout(() => {
                gameState.units.forEach(unit => {
                    updateHealthBar(unit);
                    updateUnitVisualState(unit);
                });
                updateEnemyVisibility();
                updateFogOfWar(); // Make sure fog is properly initialized
            }, 100);
            
            // Add helper to check if all player units have moved and update button state
            checkAllUnitsMoved();
            selectNextUnmovedUnit();
        });
        
        // Handle resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            gameState.camera.left = -20 * aspect;
            gameState.camera.right = 20 * aspect;
            gameState.camera.updateProjectionMatrix();
            gameState.renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Add helper to check if all player units have moved and update button state
        function checkAllUnitsMoved() {
            const btn = document.getElementById('endTurnBtn');
            const unmoved = gameState.units.filter(u => u.userData.team === TEAM.PLAYER && u.userData.movesLeft > 0);
            if (unmoved.length === 0) {
                btn.classList.add('ready');
                btn.classList.add('bounce');
            } else {
                btn.classList.remove('ready');
                btn.classList.remove('bounce');
            }
        }
        
        // Select next unmoved unit or deselect if none remain
        function selectNextUnmovedUnit() {
            const next = gameState.units.find(u => u.userData.team === TEAM.PLAYER && u.userData.movesLeft > 0);
            if (next) {
                selectUnit(next);
            } else {
                deselectUnit();
            }
        }
        
        // Animate resource flow to nearby cities
        function animateResourceFlowToCities(sourceTile, resourceType) {
            // Find nearby cities within 2 tiles
            const nearbyCities = [];
            const neighbors = getNeighbors(sourceTile, 2);
            neighbors.forEach(neighbor => {
                if (neighbor.userData.city && neighbor.userData.city.team === TEAM.PLAYER) {
                    nearbyCities.push(neighbor);
                }
            });
            
            if (nearbyCities.length === 0) return;
            
            // Create resource sprites based on type
            const resourceSprites = [];
            const spriteCount = 3; // Number of resource sprites to animate
            
            for (let i = 0; i < spriteCount; i++) {
                const sprite = createResourceSprite(resourceType);
                sprite.position.copy(sourceTile.position);
                sprite.position.y = 0.5;
                gameState.scene.add(sprite);
                resourceSprites.push(sprite);
            }
            
            // Animate each sprite to a different city
            resourceSprites.forEach((sprite, index) => {
                const targetCity = nearbyCities[index % nearbyCities.length];
                const targetPosition = targetCity.position.clone();
                targetPosition.y = 1.5; // Above the city
                
                // Animate sprite movement
                const startTime = Date.now();
                const duration = 1500;
                const startPos = sprite.position.clone();
                
                function animateSprite() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Smooth easing
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    // Move sprite
                    sprite.position.lerpVectors(startPos, targetPosition, easeProgress);
                    
                    // Add some bobbing motion
                    sprite.position.y += Math.sin(progress * Math.PI * 4) * 0.1;
                    
                    // Scale down as it approaches
                    sprite.scale.setScalar(1 - progress * 0.5);
                    
                    // Rotate
                    sprite.rotation.z = progress * Math.PI * 4;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateSprite);
                    } else {
                        // Remove sprite
                        gameState.scene.remove(sprite);
                        
                        // Show population pip fill animation on the city
                        if (index === 0) { // Only animate once per city
                            animatePopulationPipFill(targetCity, resourceType);
                        }
                    }
                }
                
                // Stagger the animations
                setTimeout(() => {
                    animateSprite();
                }, index * 200);
            });
        }
        
        // Create resource sprite based on type
        function createResourceSprite(resourceType) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Clear background
            ctx.clearRect(0, 0, 64, 64);
            
            // Draw resource icon based on type
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            let icon = 'üçé';
            let color = '#E91E63';
            
            switch (resourceType) {
                case 'farm':
                    icon = 'üåæ';
                    color = '#FFEB3B';
                    break;
                case 'mine':
                    icon = '‚õèÔ∏è';
                    color = '#FFD700';
                    break;
                case 'lumber_hut':
                    icon = 'ü™µ';
                    color = '#8D6E63';
                    break;
                case 'fruit':
                    icon = 'üçé';
                    color = '#E91E63';
                    break;
            }
            
            // Add glow effect
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.fillText(icon, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                sizeAttenuation: false
            });
            return new THREE.Sprite(material);
        }
        
        // Animate population pip fill on city
        function animatePopulationPipFill(cityTile, resourceType) {
            const city = cityTile.userData.city;
            if (!city || !city.model) return;
            
            // Create a temporary highlight effect on the population display
            const oldDisplay = city.model.getObjectByName('populationDisplay');
            if (oldDisplay) {
                // Create a flash effect
                const flashGeometry = new THREE.PlaneGeometry(1.5, 0.4);
                const flashMaterial = new THREE.MeshBasicMaterial({
                    color: 0x2196F3,
                    transparent: true,
                    opacity: 0.8
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.copy(oldDisplay.position);
                flash.position.y += 0.1;
                flash.name = 'populationFlash';
                city.model.add(flash);
                
                // Animate flash
                const startTime = Date.now();
                function animateFlash() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / 500, 1);
                    
                    flash.material.opacity = 0.8 * (1 - progress);
                    flash.scale.setScalar(1 + progress * 0.5);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateFlash);
                    } else {
                        city.model.remove(flash);
                    }
                }
                animateFlash();
                
                // Show notification about population growth based on resource type
                let message = '+2 Population';
                switch (resourceType) {
                    case 'farm':
                        message = 'üåæ +2 Population';
                        break;
                    case 'mine':
                        message = '‚õèÔ∏è +2 Population';
                        break;
                    case 'lumber_hut':
                        message = 'ü™µ +1 Population';
                        break;
                    case 'fruit':
                        message = 'üçé +1 Population';
                        break;
                }
                showResourceContributionNotification(cityTile, message);
            }
        }
        
        // City level-up is now automatic with choice prompt - no animation needed
        
        // Show resource contribution notification
        function showResourceContributionNotification(cityTile, message) {
            // Create floating text above the city
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Clear background
            ctx.clearRect(0, 0, 256, 64);
            
            // Draw text with glow effect
            ctx.shadowColor = '#2196F3';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#2196F3';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, 128, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                sizeAttenuation: false
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1, 0.25, 1);
            sprite.position.copy(cityTile.position);
            sprite.position.y = 2.5;
            gameState.scene.add(sprite);
            
            // Animate the notification
            const startTime = Date.now();
            const duration = 2000;
            
            function animateNotification() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Move up and fade out
                sprite.position.y = 2.5 + progress * 1;
                sprite.material.opacity = 1 - progress;
                
                if (progress < 1) {
                    requestAnimationFrame(animateNotification);
                } else {
                    gameState.scene.remove(sprite);
                }
            }
            
            animateNotification();
        }
        

        
        // Test level up function (temporary for debugging)
        function testLevelUp() {
            console.log('=== TEST LEVEL UP ===');
            
            // Find the first player city
            const playerCity = gameState.cities.find(city => city.team === TEAM.PLAYER);
            if (playerCity) {
                const cityTile = gameState.tiles.find(t => t.userData.city === playerCity);
                if (cityTile) {
                    console.log(`Testing level up for city: ${playerCity.name}`);
                    console.log(`Current level: ${playerCity.level}`);
                    console.log(`Current population points: ${playerCity.populationPoints}`);
                    
                    // Add population points to trigger level up
                    const nextLevelRequirement = playerCity.level * 2;
                    const neededPoints = nextLevelRequirement - playerCity.populationPoints;
                    
                    if (neededPoints > 0) {
                        playerCity.populationPoints += neededPoints;
                        console.log(`Added ${neededPoints} population points to reach ${nextLevelRequirement} (level ${playerCity.level + 1} requirement)`);
                        
                        // Recalculate population
                        calculateCityPopulation(cityTile, false);
                    } else {
                        console.log('City already has enough population points for level up');
                        // Force a level up by directly calling the choice function
                        console.log('Forcing level-up choice display...');
                        showCityLevelUpChoices(cityTile);
                    }
                }
            } else {
                console.log('No player city found');
            }
        }
        
        // Test population display function (temporary for debugging)
        function testPopulationDisplay() {
            console.log('=== TEST POPULATION DISPLAY ===');
            
            // Find the first player city
            const playerCity = gameState.cities.find(city => city.team === TEAM.PLAYER);
            if (playerCity) {
                const cityTile = gameState.tiles.find(t => t.userData.city === playerCity);
                if (cityTile) {
                    console.log(`Testing population display for city: ${playerCity.name}`);
                    console.log(`Current population points: ${playerCity.populationPoints}`);
                    console.log(`Current level: ${playerCity.level}`);
                    
                    // Force update the population display
                    createCityPopulationDisplay(playerCity.model, playerCity.populationPoints, playerCity);
                    
                    console.log('Population display updated');
                }
            } else {
                console.log('No player city found');
            }
        }
        
        // Test level-up menu function (temporary for debugging)
        function testLevelUpMenu() {
            console.log('=== TEST LEVEL-UP MENU ===');
            
            // Find the first player city
            const playerCity = gameState.cities.find(city => city.team === TEAM.PLAYER);
            if (playerCity) {
                const cityTile = gameState.tiles.find(t => t.userData.city === playerCity);
                if (cityTile) {
                    console.log(`Testing level-up menu for city: ${playerCity.name}`);
                    console.log(`Current level: ${playerCity.level}`);
                    
                    // Force show the level-up menu
                    showCityLevelUpChoices(cityTile);
                    
                    console.log('Level-up menu should be visible');
                }
            } else {
                console.log('No player city found');
            }
        }
        
        // Test population progression function (temporary for debugging)
        function testPopulationProgression() {
            console.log('=== TEST POPULATION PROGRESSION ===');
            
            // Find the first player city
            const playerCity = gameState.cities.find(city => city.team === TEAM.PLAYER);
            if (playerCity) {
                const cityTile = gameState.tiles.find(t => t.userData.city === playerCity);
                if (cityTile) {
                    console.log(`Testing population progression for city: ${playerCity.name}`);
                    console.log(`Current level: ${playerCity.level}`);
                    console.log(`Current population points: ${playerCity.populationPoints}`);
                    
                    // Simulate adding population points to see progression
                    const oldPoints = playerCity.populationPoints;
                    playerCity.populationPoints += 1;
                    
                    console.log(`Added 1 population point: ${oldPoints} -> ${playerCity.populationPoints}`);
                    
                    // Check if this triggers a level-up
                    const oldLevel = playerCity.level;
                    const newLevel = Math.floor(playerCity.populationPoints / 2) + 1;
                    
                    console.log(`Level check: ${oldLevel} -> ${newLevel} (${playerCity.populationPoints} points)`);
                    
                    if (newLevel > oldLevel) {
                        playerCity.level = newLevel;
                        console.log(`City ${playerCity.name} leveled up from ${oldLevel} to ${newLevel}!`);
                        
                        // Show level-up menu
                        showCityLevelUpChoices(cityTile);
                    }
                    
                    // Update the population display
                    createCityPopulationDisplay(playerCity.model, playerCity.populationPoints, playerCity);
                    
                    console.log('Population display updated');
                }
            } else {
                console.log('No player city found');
            }
        }
        
        // Harvest fruit function
        function harvestFruit(tile) {
            if (tile.userData.resource !== 'fruit') return;
            
            // Mark fruit as harvested (but keep it for population)
            tile.userData.resource = 'harvested_fruit';
            
            // Remove fruit visual
            if (tile.userData.feature) {
                gameState.scene.remove(tile.userData.feature);
                tile.userData.feature = null;
            }
            
            // Add stars
            gameState.stars += 1;
            document.getElementById('stars').textContent = gameState.stars;
            
            // Animate fruit flow to nearby cities
            animateResourceFlowToCities(tile, 'fruit');
            
            // Update nearby city populations after animation
            setTimeout(() => {
                const neighbors = getNeighbors(tile, 2);
                neighbors.forEach(neighbor => {
                    if (neighbor.userData.city) {
                        calculateCityPopulation(neighbor);
                    }
                });
                
                // Debug: Log population changes
                console.log('Fruit harvested, updating city populations...');
                neighbors.forEach(neighbor => {
                    if (neighbor.userData.city) {
                        console.log(`City ${neighbor.userData.city.name}: ${neighbor.userData.city.populationPoints} population points`);
                    }
                });
            }, 1500);
            
            // Play sound
            soundManager.play('collect');
            
            // Hide menu
            document.getElementById('improvementMenu').style.display = 'none';
        }
    </script>
</body>
</html>