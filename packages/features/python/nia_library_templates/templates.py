# Auto-generated from descriptors/library-templates.json
# Do not edit this file directly - run codegen instead
"""
Library template metadata for Nia Universal HTML generation.
"""
from typing import Optional

# All available library types
LIBRARY_TYPES: list[str] = ["tool","game"]

# All library templates (without full HTML content, just metadata)
LIBRARY_TEMPLATES: list[dict] = [
    {
        "id": "counter_widget_v1",
        "library_type": "tool",
        "name": "Counter Widget Starter",
        "description": "Simple animated counter with increment/decrement, reset, and persistence hooks.",
        "tags": ["counter", "widget", "persisted"],
    },
    {
        "id": "quick_poll_v1",
        "library_type": "tool",
        "name": "Quick Poll (Two Option)",
        "description": "Two-option poll with percentages and persistence.",
        "tags": ["poll", "vote", "persisted"],
    },
    {
        "id": "party_pack_poll",
        "library_type": "tool",
        "name": "Party Pack: Emoji Vote",
        "description": "Emoji-based quick vote with live tally and persistence.",
        "tags": ["poll", "emoji", "fun", "persisted"],
    },
    {
        "id": "party_pack_score",
        "library_type": "tool",
        "name": "Party Pack: Score Keeper",
        "description": "Two-team score keeper with quick adjust, reset, and persistence.",
        "tags": ["score", "teams", "game", "persisted"],
    },
    {
        "id": "space_invaders_lite",
        "library_type": "game",
        "name": "Space Invaders Lite",
        "description": "Simple version of the arcade classic lane shooter with high-score persistence.",
        "tags": ["game", "shooter", "arcade", "persisted"],
    },
    {
        "id": "checkers_challenge",
        "library_type": "game",
        "name": "Classic Checkers Challenge",
        "description": "Classic checkers game with a polished UI and smooth gameplay, both single player and multi-player modes, with turn-based mechanics / game persistence.",
        "tags": ["game", "board", "strategy", "classic"],
    },
    {
        "id": "chess_persistent",
        "library_type": "game",
        "name": "Chess (Single/Multiplayer)",
        "description": "Lightweight chess move tracker that binds white/black to a user and persists moves via NiaAPI.",
        "tags": ["game", "chess", "board", "persisted"],
    }
]


def get_template_by_id(template_id: str) -> Optional[dict]:
    """Get a template by its ID."""
    for t in LIBRARY_TEMPLATES:
        if t["id"] == template_id:
            return t
    return None


def get_templates_by_type(library_type: str) -> list[dict]:
    """Get all templates of a specific library type."""
    return [t for t in LIBRARY_TEMPLATES if t["library_type"] == library_type]


def build_prompt_guidance() -> str:
    """
    Build a prompt-friendly string of all available library templates
    for inclusion in bot tool descriptions.
    """
    if not LIBRARY_TEMPLATES:
        return ""

    lines: list[str] = [
        "",
        "AVAILABLE LIBRARY TEMPLATES:",
        "When the user's request matches one of these templates, include library_type and library_template_id in your tool call.",
        "",
    ]

    # Group by library type
    for lib_type in LIBRARY_TYPES:
        type_templates = get_templates_by_type(lib_type)
        if type_templates:
            lines.append(f'{lib_type.upper()} TEMPLATES (library_type: "{lib_type}"):')
            for t in type_templates:
                lines.append(f'- library_template_id: "{t["id"]}"')
                lines.append(f'  Name: {t["name"]}')
                lines.append(f'  Description: {t["description"]}')
                lines.append("")

    lines.append("If no template matches the user's request, omit library_type and library_template_id to generate from scratch.")

    return "\n".join(lines)
