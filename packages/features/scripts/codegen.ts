import { existsSync, readFileSync, mkdirSync, writeFileSync } from 'fs';
import { join } from 'path';
import { getLogger } from '../src/logger';

type ContentDefinitionDesc = {
  name: string;
  description: string;
  access: {
    tenantRole: string;
    allowAnonymous: boolean;
  };
  dataModel: {
    block: string;
    indexer: string[];
    jsonSchema: any;
    parent: { type: string; field: string };
  };
  uiConfig: {
    card: { titleField: string; descriptionField: string };
    detailView: { displayFields: string[] };
    listView: { displayFields: string[] };
  };
};

/**
 * Lightweight template info for Python codegen (excludes full HTML content)
 */
type LibraryTemplateInfo = {
  id: string;
  libraryType: 'game' | 'app' | 'tool' | 'interactive';
  name: string;
  description: string;
  tags?: string[];
};

const root = join(__dirname, '..');
const descPath = join(root, 'descriptors', 'content-definitions.json');
const templatesDescPath = join(root, 'descriptors', 'library-templates.json');
const outDir = join(root, 'src', 'generated');
const pyPkgRoot = join(root, 'python', 'nia_content_definitions');
const pyTemplatesPkgRoot = join(root, 'python', 'nia_library_templates');
const logger = getLogger('features:codegen');

const writeIfChanged = (path: string, content: string): boolean => {
  if (existsSync(path)) {
    try {
      const current = readFileSync(path, 'utf-8');
      if (current === content) {
        return false;
      }
    } catch {
      // Fall through to rewrite if read fails
    }
  }

  writeFileSync(path, content, 'utf-8');
  return true;
};

function run() {
  const json = JSON.parse(readFileSync(descPath, 'utf-8')) as {
    contentDefinitions: ContentDefinitionDesc[];
  };
  mkdirSync(outDir, { recursive: true });
  mkdirSync(pyPkgRoot, { recursive: true });

  // Generate TypeScript
  const tsImports = `import { IDynamicContent } from "@nia/prism/core/blocks/dynamicContent.block";`;
  
  const tsDefinitions = json.contentDefinitions
    .map(def => {
      const defName = `${def.name}Definition`;
      return `export const ${defName}: IDynamicContent = ${JSON.stringify(def, null, 2)};`;
    })
    .join('\n\n');

  const tsExportList = json.contentDefinitions
    .map(def => `${def.name}Definition`)
    .join(', ');

  const ts = `// Auto-generated from descriptors/content-definitions.json
// Do not edit this file directly - edit the descriptor instead
${tsImports}

${tsDefinitions}

export const ALL_DEFINITIONS = [${tsExportList}];
`;

  const tsPath = join(outDir, 'definitions.ts');
  const tsUpdated = writeIfChanged(tsPath, ts);

  // Generate Python
  const pyInit = `# Auto-generated. Do not edit.
from .definitions import (
${json.contentDefinitions.map(def => `    ${def.name.toUpperCase()}_DEFINITION,`).join('\n')}
    ALL_DEFINITIONS
)

from .mesh_helpers import (
    register_content_definition,
    ensure_content_definitions,
    register_all_definitions
)

__all__ = [
${json.contentDefinitions.map(def => `    '${def.name.toUpperCase()}_DEFINITION',`).join('\n')}
    'ALL_DEFINITIONS',
    'register_content_definition',
    'ensure_content_definitions',
    'register_all_definitions'
]
`;
  const pyInitPath = join(pyPkgRoot, '__init__.py');
  const pyInitUpdated = writeIfChanged(pyInitPath, pyInit);

  const pyDefinitions = json.contentDefinitions
    .map(def => {
      const constName = `${def.name.toUpperCase()}_DEFINITION`;
      // Convert JSON to Python-compatible format (true/false → True/False, null → None)
      const jsonStr = JSON.stringify(def, null, 4)
        .replace(/: true/g, ': True')
        .replace(/: false/g, ': False')
        .replace(/: null/g, ': None');
      return `${constName} = ${jsonStr}`;
    })
    .join('\n\n');

  const pyExportList = json.contentDefinitions
    .map(def => `${def.name.toUpperCase()}_DEFINITION`)
    .join(',\n    ');

  const py = `# Auto-generated from descriptors/content-definitions.json
# Do not edit this file directly - edit the descriptor instead
"""
Content type definitions for Nia Universal
Auto-generated from TypeScript IDynamicContent descriptors
"""

${pyDefinitions}

ALL_DEFINITIONS = [
    ${pyExportList}
]
`;

  const pyDefPath = join(pyPkgRoot, 'definitions.py');
  const pyDefUpdated = writeIfChanged(pyDefPath, py);

  if (tsUpdated) {
    logger.info('Generated TypeScript definitions', { output: tsPath });
  } else {
    logger.info('TypeScript definitions unchanged', { output: tsPath });
  }
  if (pyInitUpdated || pyDefUpdated) {
    logger.info('Generated Python definitions', { output: pyDefPath });
  } else {
    logger.info('Python definitions unchanged', { output: pyDefPath });
  }

  // Generate Library Templates Python package
  generateLibraryTemplates();
}

function generateLibraryTemplates() {
  // Read the library templates descriptor
  let templatesJson: { templates: LibraryTemplateInfo[] };
  try {
    templatesJson = JSON.parse(readFileSync(templatesDescPath, 'utf-8'));
  } catch (e) {
    logger.warn('No library-templates descriptor found; skipping library templates generation');
    return;
  }

  mkdirSync(pyTemplatesPkgRoot, { recursive: true });

  const templates = templatesJson.templates;
  const libraryTypes = Array.from(new Set(templates.map(t => t.libraryType)));

  // Generate README.md (required by pyproject.toml)
  const readme = `# nia-library-templates

Auto-generated library template metadata for Nia Universal HTML generation.

> **Note:** This package is auto-generated from \`descriptors/library-templates.json\`.
> Do not edit these files directly - run \`npm run codegen\` instead.

## Usage

\`\`\`python
from nia_library_templates import (
    LIBRARY_TEMPLATES,
    LIBRARY_TYPES,
    get_template_by_id,
    get_templates_by_type,
    build_prompt_guidance,
)

# Get all templates
print(LIBRARY_TEMPLATES)

# Get templates by type
tool_templates = get_templates_by_type("tool")
game_templates = get_templates_by_type("game")

# Get a specific template by ID
template = get_template_by_id("counter_widget_v1")

# Generate prompt guidance for bot tools
guidance = build_prompt_guidance()
\`\`\`
`;
  const pyTemplatesReadmePath = join(pyTemplatesPkgRoot, 'README.md');
  const pyTemplatesReadmeUpdated = writeIfChanged(pyTemplatesReadmePath, readme);

  // Generate Python __init__.py
  const pyInit = `# Auto-generated from descriptors/library-templates.json
# Do not edit this file directly - run codegen instead
"""
Library template metadata for Nia Universal HTML generation.
This module provides template information for bot tool prompts.
"""
from .templates import (
    LIBRARY_TEMPLATES,
    LIBRARY_TYPES,
    get_template_by_id,
    get_templates_by_type,
    build_prompt_guidance,
)

__all__ = [
    'LIBRARY_TEMPLATES',
    'LIBRARY_TYPES',
    'get_template_by_id',
    'get_templates_by_type',
    'build_prompt_guidance',
]
`;
  const pyTemplatesInitPath = join(pyTemplatesPkgRoot, '__init__.py');
  const pyTemplatesInitUpdated = writeIfChanged(pyTemplatesInitPath, pyInit);

  // Generate Python templates.py
  const pyTemplatesList = templates
    .map(t => {
      const tagsStr = t.tags && t.tags.length > 0 
        ? `[${t.tags.map(tag => `"${tag}"`).join(', ')}]`
        : '[]';
      return `    {
        "id": "${t.id}",
        "library_type": "${t.libraryType}",
        "name": "${t.name}",
        "description": "${t.description.replace(/"/g, '\\"')}",
        "tags": ${tagsStr},
    }`;
    })
    .join(',\n');

  const pyTemplates = `# Auto-generated from descriptors/library-templates.json
# Do not edit this file directly - run codegen instead
"""
Library template metadata for Nia Universal HTML generation.
"""
from typing import Optional

# All available library types
LIBRARY_TYPES: list[str] = ${JSON.stringify(libraryTypes)}

# All library templates (without full HTML content, just metadata)
LIBRARY_TEMPLATES: list[dict] = [
${pyTemplatesList}
]


def get_template_by_id(template_id: str) -> Optional[dict]:
    """Get a template by its ID."""
    for t in LIBRARY_TEMPLATES:
        if t["id"] == template_id:
            return t
    return None


def get_templates_by_type(library_type: str) -> list[dict]:
    """Get all templates of a specific library type."""
    return [t for t in LIBRARY_TEMPLATES if t["library_type"] == library_type]


def build_prompt_guidance() -> str:
    """
    Build a prompt-friendly string of all available library templates
    for inclusion in bot tool descriptions.
    """
    if not LIBRARY_TEMPLATES:
        return ""

    lines: list[str] = [
        "",
        "AVAILABLE LIBRARY TEMPLATES:",
        "When the user's request matches one of these templates, include library_type and library_template_id in your tool call.",
        "",
    ]

    # Group by library type
    for lib_type in LIBRARY_TYPES:
        type_templates = get_templates_by_type(lib_type)
        if type_templates:
            lines.append(f'{lib_type.upper()} TEMPLATES (library_type: "{lib_type}"):')
            for t in type_templates:
                lines.append(f'- library_template_id: "{t["id"]}"')
                lines.append(f'  Name: {t["name"]}')
                lines.append(f'  Description: {t["description"]}')
                lines.append("")

    lines.append("If no template matches the user's request, omit library_type and library_template_id to generate from scratch.")

    return "\\n".join(lines)
`;

  const pyTemplatesPath = join(pyTemplatesPkgRoot, 'templates.py');
  const pyTemplatesUpdated = writeIfChanged(pyTemplatesPath, pyTemplates);

  if (pyTemplatesReadmeUpdated || pyTemplatesInitUpdated || pyTemplatesUpdated) {
    logger.info('Generated Python library templates', { output: pyTemplatesPath });
  } else {
    logger.info('Python library templates unchanged', { output: pyTemplatesPath });
  }
}

run();
