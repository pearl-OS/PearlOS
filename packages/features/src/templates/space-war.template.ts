import type { LibraryTemplateDescriptor } from './library-templates';
// import { buildStorageBootstrapSnippet } from './storage-library.template';

// const STORAGE_BOOTSTRAP = buildStorageBootstrapSnippet();

export const spaceWarTemplate: LibraryTemplateDescriptor = {
    id: 'space_war',
    libraryType: 'game',
    name: 'Space War',
    filename: 'space-war.html',
    description: 'Classic arcade-style space shooter 1:1 against robot player.',
    tags: ['game', 'shooter', 'arcade', 'vector', 'retro' ],
    content: [ /* html */
        '<head>',
        '<meta charset="utf-8">',
        '<meta name="viewport" content="width=device-width,initial-scale=1">',
        '<title>Space War Game</title>',
        '<style>',
        ':root {',
        '  color-scheme: dark;',
        '  --neon-cyan: #0ff9ff;',
        '  --neon-magenta: #ff5cff;',
        '  --hud-edge: rgba(0, 255, 255, 0.22);',
        '  --panel-bg: rgba(0, 12, 18, 0.55);',
        '  --text-primary: #b5feff;',
        '  --body-bg: radial-gradient(circle at 20% 20%, #052738 0%, #01000b 52%, #000 100%);',
        '  --border-soft: rgba(0, 255, 255, 0.18);',
        '  font-family: "Courier New", Courier, monospace;',
        '}',
        '*, *::before, *::after { box-sizing: border-box; }',
        'html, body { height: 100%; }',
        'body {',
        '  margin: 0;',
        '  min-height: 100vh;',
        '  background: var(--body-bg);',
        '  color: var(--text-primary);',
        '  display: flex;',
        '  align-items: stretch;',
        '  justify-content: center;',
        '  transition: background 0.8s ease;',
        '  letter-spacing: 0.02em;',
        '}',
        'body.playing { background: #000; overflow: hidden; height: 100vh; }',
        '.game-wrapper {',
        '  width: min(1080px, calc(100vw - 3rem));',
        '  margin: 2rem auto;',
        '  background: rgba(0, 0, 0, 0.82);',
        '  border: 1px solid var(--hud-edge);',
        '  border-radius: 22px;',
        '  padding: 1.75rem;',
        '  display: flex;',
        '  flex-direction: column;',
        '  gap: 1.5rem;',
        '  position: relative;',
        '  box-shadow: 0 0 45px rgba(0, 255, 255, 0.18), inset 0 0 120px rgba(0, 40, 40, 0.35);',
        '  min-height: 100vh;',
        '  transition: width 0.8s cubic-bezier(.36,.07,.19,.97), height 0.8s cubic-bezier(.36,.07,.19,.97), border-radius 0.8s ease, margin 0.8s ease, padding 0.8s ease, box-shadow 0.8s ease;',
        '}',
        'body.playing .game-wrapper { width: 100vw; height: 100vh; margin: 0; border-radius: 0; padding: 0; box-shadow: none; background: #000; gap: 0; }',
        '.titlebar {',
        '  display: flex; align-items: center; justify-content: space-between;',
        '  text-transform: uppercase; letter-spacing: 0.12em; color: var(--text-primary);',
        '  font-size: 0.95rem; padding-right: 0.5rem;',
        '}',
        '.titlebar span { color: var(--neon-cyan); text-shadow: 0 0 12px rgba(0, 255, 255, 0.55); }',
        '.titlebar small { color: rgba(255, 255, 255, 0.55); font-size: 0.7rem; letter-spacing: 0.2em; }',
        '.cosmic-card {',
        '  border: 1px solid var(--hud-edge);',
        '  border-radius: 16px;',
        '  padding: 1.2rem;',
        '  background: var(--panel-bg);',
        '  box-shadow: inset 0 0 30px rgba(0, 60, 60, 0.25), 0 0 30px rgba(0, 255, 255, 0.08);',
        '  position: relative;',
        '}',
        '.hud { display: flex; flex-direction: column; gap: 1.15rem; transform-origin: top center; transition: transform 0.9s ease, opacity 0.9s ease, max-height 0.9s ease; }',
        '.game-wrapper.playing .hud { transform: translateY(-140%) rotateX(32deg); opacity: 0; pointer-events: none; max-height: 0; height: 0; overflow: hidden; padding: 0; margin: 0; }',
        '.status-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1.2rem; }',
        '.status-card {',
        '  border: 1px solid var(--border-soft);',
        '  border-radius: 12px;',
        '  padding: 1rem;',
        '  background: rgba(0, 0, 0, 0.45);',
        '  text-shadow: 0 0 6px rgba(0, 255, 255, 0.45);',
        '}',
        '.status-card h2 { margin: 0 0 0.55rem 0; font-size: 1.05rem; text-transform: uppercase; letter-spacing: 0.1em; }',
        '.status-card[data-player="alpha"] { color: var(--neon-cyan); border-color: rgba(0, 255, 255, 0.35); }',
        '.status-card[data-player="robot"] { color: var(--neon-magenta); border-color: rgba(255, 92, 255, 0.35); text-shadow: 0 0 6px rgba(255, 92, 255, 0.5); }',
        '.status-card dl { margin: 0; display: grid; grid-template-columns: max-content 1fr; gap: 0.25rem 0.6rem; align-items: center; }',
        '.status-card dt { font-size: 0.72rem; text-transform: uppercase; letter-spacing: 0.18em; opacity: 0.7; }',
        '.status-card dd { margin: 0; font-size: 1.15rem; }',
        '.status-card.status-round { color: var(--text-primary); border-color: rgba(0, 180, 255, 0.25); }',
        '.status-card.status-round p { margin: 0.2rem 0; font-size: 0.9rem; letter-spacing: 0.08em; }',
        '.controls-panel { display: flex; flex-wrap: wrap; gap: 1rem; align-items: stretch; }',
        '.control-set {',
        '  flex: 1 1 240px;',
        '  border: 1px dashed rgba(0, 255, 255, 0.28);',
        '  border-radius: 12px;',
        '  padding: 0.85rem 1rem;',
        '  background: rgba(0, 18, 28, 0.45);',
        '  color: var(--text-primary);',
        '}',
        '.control-set h3 { margin: 0 0 0.5rem 0; font-size: 0.88rem; letter-spacing: 0.16em; text-transform: uppercase; color: rgba(255, 255, 255, 0.72); }',
        '.control-set p { margin: 0 0 0.6rem; font-size: 0.8rem; line-height: 1.4; letter-spacing: 0.08em; color: rgba(200, 255, 255, 0.68); }',
        '.control-list { list-style: none; margin: 0; padding: 0; display: grid; gap: 0.35rem; font-size: 0.82rem; }',
        '.control-list li { display: flex; justify-content: space-between; align-items: center; gap: 0.6rem; }',
        '.control-list span {',
        '  font-size: 0.75rem;',
        '  padding: 0.15rem 0.5rem;',
        '  border: 1px solid rgba(0, 255, 255, 0.45);',
        '  border-radius: 6px;',
        '  min-width: 3.4rem;',
        '  text-align: center;',
        '  color: rgba(0, 255, 255, 0.82);',
        '  text-shadow: 0 0 8px rgba(0, 255, 255, 0.35);',
        '}',
        '.control-set[data-side="robot"] span {',
        '  border-color: rgba(255, 92, 255, 0.45);',
        '  color: rgba(255, 92, 255, 0.82);',
        '  text-shadow: 0 0 8px rgba(255, 92, 255, 0.35);',
        '}',
        '.panel-actions { display: flex; flex-direction: column; justify-content: center; gap: 0.65rem; min-width: 180px; }',
        'button {',
        '  font-family: inherit; font-size: 0.95rem; letter-spacing: 0.08em; text-transform: uppercase;',
        '  border: 1px solid var(--neon-cyan); background: transparent; color: var(--neon-cyan);',
        '  padding: 0.65rem 1.45rem; border-radius: 0.9rem; cursor: pointer;',
        '  transition: filter 0.25s ease, transform 0.25s ease, box-shadow 0.25s ease, opacity 0.25s ease;',
        '  box-shadow: 0 0 12px rgba(0, 255, 255, 0.25);',
        '}',
        'button:hover:not(:disabled) { filter: drop-shadow(0 0 6px rgba(0, 255, 255, 0.85)); transform: translateY(-2px); }',
        'button:active:not(:disabled) { transform: translateY(0); }',
        'button:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }',
        'button.ghost { border-color: rgba(255, 255, 255, 0.4); color: rgba(255, 255, 255, 0.7); box-shadow: none; }',
        '.game-stage {',
        '  position: relative; flex: 1 1 auto; min-height: 360px;',
        '  border: 1px solid var(--hud-edge); border-radius: 16px; overflow: hidden;',
        '  display: flex; align-items: center; justify-content: center; background: #000;',
        '  box-shadow: inset 0 0 45px rgba(0, 255, 255, 0.08); transition: border-radius 0.6s ease;',
        '  min-width: 0;',
        '}',
        '.game-wrapper.playing .game-stage { border-radius: 0; flex: 1 1 100%; border: none; box-shadow: none; width: 100%; height: 100%; }',
        '.game-stage::before, .game-stage::after { content: ""; position: absolute; inset: 0; pointer-events: none; }',
        '.game-stage::before { background-image: radial-gradient(circle at center, rgba(0, 255, 255, 0.12) 0, transparent 60%); opacity: 0.18; mix-blend-mode: screen; }',
        '.game-stage::after { background-image: repeating-linear-gradient(0deg, rgba(0, 255, 255, 0.08) 0, rgba(0, 255, 255, 0.08) 1px, transparent 3px, transparent 8px); opacity: 0.08; }',
        '.game-wrapper.playing .game-stage::before, .game-wrapper.playing .game-stage::after { display: none; }',
        'canvas { width: 100%; height: 100%; max-width: 100%; max-height: none; display: block; background: #000; image-rendering: pixelated; }',
        '.vector-overlay {',
        '  position: absolute; inset: 0; display: grid; place-items: center;',
        '  background: rgba(0, 0, 0, 0.68); color: var(--text-primary); text-shadow: 0 0 12px rgba(0, 255, 255, 0.45);',
        '  transition: opacity 0.5s ease; padding: 2rem; z-index: 2;',
        '}',
        '.vector-overlay.is-hidden, .game-wrapper.playing .vector-overlay { opacity: 0; pointer-events: none; }',
        '.overlay-plate {',
        '  border: 1px solid rgba(0, 255, 255, 0.35); border-radius: 16px; padding: 2.2rem;',
        '  background: rgba(0, 12, 16, 0.7); box-shadow: 0 0 40px rgba(0, 255, 255, 0.18);',
        '  max-width: 420px; text-align: center;',
        '}',
        '.overlay-title { margin: 0 0 0.75rem 0; font-size: 1.25rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--neon-cyan); }',
        '.overlay-body { margin: 0; font-size: 0.95rem; letter-spacing: 0.08em; color: rgba(200, 255, 255, 0.85); }',
        '.control-slider {',
        '  display: grid;',
        '  gap: 0.45rem;',
        '  font-size: 0.82rem;',
        '  color: rgba(200, 255, 255, 0.9);',
        '}',
        '.control-slider label { display: flex; justify-content: space-between; align-items: center; letter-spacing: 0.08em; text-transform: uppercase; font-size: 0.78rem; }',
        '.control-slider input[type="range"] {',
        '  width: 100%;',
        '  accent-color: var(--neon-cyan);',
        '  cursor: pointer;',
        '}',
        '.retro-toggle { display: flex; align-items: center; gap: 0.55rem; font-size: 0.82rem; color: rgba(200, 255, 255, 0.82); letter-spacing: 0.05em; }',
        '.retro-toggle input { accent-color: var(--neon-cyan); width: 18px; height: 18px; }',
        '.retro-toggle small { opacity: 0.7; font-size: 0.75rem; }',
        '.mobile-controls {',
        '  position: fixed;',
        '  bottom: 18px;',
        '  left: 18px;',
        '  z-index: 8;',
        '  display: none;',
        '}',
        'body.mobile-controls-active .mobile-controls { display: grid; }',
        '.mobile-controls .cluster {',
        '  display: grid;',
        '  grid-template-columns: repeat(3, 64px);',
        '  grid-template-rows: repeat(3, 64px);',
        '  gap: 8px;',
        '}',
        '.mobile-controls button {',
        '  width: 64px;',
        '  height: 64px;',
        '  border-radius: 12px;',
        '  border: 1px solid rgba(0, 255, 255, 0.35);',
        '  background: rgba(0, 0, 0, 0.55);',
        '  color: #e8f0ff;',
        '  font-weight: 700;',
        '  font-size: 1rem;',
        '  box-shadow: 0 6px 16px rgba(0, 255, 255, 0.25);',
        '  display: grid;',
        '  place-items: center;',
        '}',
        '.mobile-controls button:active { transform: scale(0.95); }',
        '.mobile-controls .thrust { grid-area: 1 / 2 / 2 / 3; }',
        '.mobile-controls .left { grid-area: 2 / 1 / 3 / 2; }',
        '.mobile-controls .fire { grid-area: 2 / 2 / 3 / 3; }',
        '.mobile-controls .right { grid-area: 2 / 3 / 3 / 4; }',
        '.mobile-controls .hyper { grid-area: 3 / 2 / 4 / 3; }',
        '.mobile-controls svg { width: 28px; height: 28px; stroke: #0ff9ff; fill: none; stroke-width: 2; filter: drop-shadow(0 0 6px rgba(0,255,255,0.5)); stroke-linecap: round; stroke-linejoin: round; }',
        'body.retro-colors .mobile-controls svg { stroke: #72ff72; filter: drop-shadow(0 0 8px rgba(114,255,114,0.65)); }',
        'body.retro-colors .mobile-controls button { border-color: rgba(114, 255, 114, 0.45); box-shadow: 0 6px 16px rgba(114, 255, 114, 0.35); }',
        '@media (max-width: 960px) {',
        '  .game-wrapper { width: min(900px, calc(100vw - 1.5rem)); padding: 1.25rem; }',
        '  .panel-actions { width: 100%; flex-direction: row; justify-content: flex-start; }',
        '}',
        '@media (max-width: 680px) {',
        '  body { align-items: stretch; }',
        '  .game-wrapper { margin: 0; border-radius: 0; width: 100%; min-height: 100vh; }',
        '  .hud { gap: 0.9rem; }',
        '  .control-set { flex: 1 1 100%; }',
        '  .panel-actions { flex-direction: column; }',
        '}',
        '@media (prefers-reduced-motion: reduce) {',
        '  *, *::before, *::after { animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; scroll-behavior: auto !important; }',
        '}',
        '</style>',
        '</head>',
        '<body>',
        '<div class="game-wrapper">',
        '  <header class="titlebar">',
        '    <div>Space War Game</div>',
        '    <div><span>Vectorbeam Tribute</span> <small>1977 SpaceWar! homage</small></div>',
        '  </header>',
        '  <div class="hud cosmic-card">',
        '    <div class="status-grid">',
        '      <div class="status-card" data-player="alpha">',
        '        <h2>Alpha Vector</h2>',
        '        <dl>',
        '          <dt>Score</dt><dd data-stat="score">0</dd>',
        '          <dt>Lives</dt><dd data-stat="lives">3</dd>',
        '        </dl>',
        '      </div>',
        '      <div class="status-card" data-player="robot">',
        '        <h2>Robo Vector</h2>',
        '        <dl>',
        '          <dt>Score</dt><dd data-stat="score">0</dd>',
        '          <dt>Lives</dt><dd data-stat="lives">3</dd>',
        '        </dl>',
        '      </div>',
        '      <div class="status-card status-round">',
        '        <h2>Mission Status</h2>',
        '        <p>Round <strong data-round>1</strong></p>',
        '        <p>First to <strong data-target-score>7</strong> victories</p>',
        '        <p>Ships per round: <strong data-lives-round>3</strong></p>',
        '      </div>',
        '    </div>',
        '    <div class="controls-panel">',
        '      <div class="control-set" data-side="alpha">',
        '        <h3>Commander Alpha (Left)</h3>',
        '        <p>Keyboard cluster: W thrust • A/D rotate • S fire • X hyperspace.</p>',
        '        <p>Mouse / Touch (mobile friendly): Move pointer to face target while held. Tap / click to fire. Hold press (or right click) to thrust. Double-tap to hyperspace.</p>',
        '        <ul class="control-list">',
        '          <li><span>W</span> Thrust</li>',
        '          <li><span>A</span> Rotate Left</li>',
        '          <li><span>D</span> Rotate Right</li>',
        '          <li><span>S</span> Fire Torpedo</li>',
        '          <li><span>X</span> Hyperspace (risky)</li>',
        '          <li><span>Click</span> Aim / Fire</li>',
        '          <li><span>Hold</span> Thrust (tap & hold / right click)</li>',
        '        </ul>',
        '      </div>',
        '      <div class="control-set" data-side="robot">',
        '        <h3>Robo Vector (Right)</h3>',
        '        <p>Autonomous classic robot pilot engages predictive firing, strafing, and evasive maneuvers.</p>',
        '        <ul class="control-list">',
        '          <li><span>AI</span> Vector aim assistance</li>',
        '          <li><span>Auto</span> Adaptive thrust + rotation</li>',
        '          <li><span>∞</span> Hyperspace evasion when cornered</li>',
        '        </ul>',
        '      </div>',
        '      <div class="control-set">',
        '        <h3>Physics Controls</h3>',
        '        <div class="control-slider">',
        '          <label for="gravityRange">Gravity <span data-gravity-label>100%</span></label>',
        '          <input id="gravityRange" type="range" min="0" max="100" step="1" value="100">',
        '          <p style="margin:0;font-size:0.78rem;opacity:0.78;">0 = no gravity • 100 = 5% of original maximum</p>',
        '        </div>',
        '        <label class="retro-toggle" for="retroColorsToggle">',
        '          <input id="retroColorsToggle" type="checkbox" checked>',
        '          <span>Retro CRT Green mode</span>',
        '          <small>(default on)</small>',
        '        </label>',
        '      </div>',
        '      <div class="panel-actions">',
        '        <button type="button" data-action="start">Engage Simulation</button>',
        '        <button type="button" data-action="reset" class="ghost" disabled>Reset to Briefing</button>',
        '      </div>',
        '    </div>',
        '  </div>',
        '  <div class="game-stage cosmic-card">',
        '    <canvas id="gameCanvas" width="960" height="540" tabindex="0"></canvas>',
        '    <div class="vector-overlay" data-overlay>',
        '      <div class="overlay-plate">',
        '        <p class="overlay-title" data-overlay-title>Space War Game</p>',
        '        <p class="overlay-body" data-overlay-body>Use the mission controls to engage the simulation. Once initiated, the combat display will expand to full viewport while the briefing panels roll away.</p>',
        '      </div>',
        '    </div>',
        '  </div>',
        '  <div class="mobile-controls" data-mobile-controls aria-label="Mobile flight controls">',
        '    <div class="cluster">',
        '      <button class="thrust" data-key="KeyW" data-action="thrust" aria-label="Thrust">',
        '        <svg viewBox="0 0 24 24" aria-hidden="true">',
        '          <path d="M12 4 L6.5 12 H10.5 V20 H13.5 V12 H17.5 Z" />',
        '        </svg>',
        '      </button>',
        '      <button class="left" data-key="KeyA" data-action="left" aria-label="Rotate Left">',
        '        <svg viewBox="0 0 24 24" aria-hidden="true">',
        '          <path d="M15 6 L9 12 L15 18" />',
        '          <path d="M9 12 H18" />',
        '        </svg>',
        '      </button>',
        '      <button class="fire" data-key="KeyS" data-action="fire" aria-label="Fire Torpedo">',
        '        <svg viewBox="0 0 24 24" aria-hidden="true">',
        '          <path d="M12 4 L14 10 L20 12 L14 14 L12 20 L10 14 L4 12 L10 10 Z" />',
        '        </svg>',
        '      </button>',
        '      <button class="right" data-key="KeyD" data-action="right" aria-label="Rotate Right">',
        '        <svg viewBox="0 0 24 24" aria-hidden="true">',
        '          <path d="M9 6 L15 12 L9 18" />',
        '          <path d="M6 12 H15" />',
        '        </svg>',
        '      </button>',
        '      <button class="hyper" data-key="KeyX" data-action="hyperspace" aria-label="Hyperspace">',
        '        <svg viewBox="0 0 24 24" aria-hidden="true">',
        '          <circle cx="12" cy="12" r="6" />',
        '          <path d="M12 2 V6 M12 18 V22 M2 12 H6 M18 12 H22" />',
        '        </svg>',
        '      </button>',
        '    </div>',
        '  </div>',
        '</div>',
        '<script>',
        '(() => {',
        "  const canvas = document.getElementById('gameCanvas');",
        "  const ctx = canvas.getContext('2d');",
        "  const wrapper = document.querySelector('.game-wrapper');",
        "  const stage = document.querySelector('.game-stage');",
        "  const body = document.body;",
        "  const overlay = document.querySelector('[data-overlay]');",
        "  const overlayTitle = document.querySelector('[data-overlay-title]');",
        "  const overlayBody = document.querySelector('[data-overlay-body]');",
        "  const startButton = document.querySelector('[data-action=\"start\"]');",
        "  const resetButton = document.querySelector('[data-action=\"reset\"]');",
        "  const scoreAlpha = document.querySelector('[data-player=\"alpha\"] [data-stat=\"score\"]');",
        "  const livesAlpha = document.querySelector('[data-player=\"alpha\"] [data-stat=\"lives\"]');",
        "  const scoreRobot = document.querySelector('[data-player=\"robot\"] [data-stat=\"score\"]');",
        "  const livesRobot = document.querySelector('[data-player=\"robot\"] [data-stat=\"lives\"]');",
        "  const roundIndicator = document.querySelector('[data-round]');",
        "  const targetScoreEl = document.querySelector('[data-target-score]');",
        "  const livesPerRoundEl = document.querySelector('[data-lives-round]');",
        "  const gravityRange = document.getElementById('gravityRange');",
        "  const gravityLabel = document.querySelector('[data-gravity-label]');",
        "  const retroColorsToggle = document.getElementById('retroColorsToggle');",
        '',
        '  const SHOT_SPEED = 525;',
        '  const PHYSICS_SLOWDOWN = 0.5;',
        '  const ROBOT_SHIP_SCALE = 1.0;',
        '  const SHIP_MAX_SPEED = 500;',
        '  const GRAVITY_BASE = 2600; // original gravity setting baseline',
        '  const GRAVITY_MAX_SCALE = 0.02; // 2% of original maximum',
        '  const BACKGROUND_SHIP_SPAWN_MIN = 8; // seconds',
        '  const BACKGROUND_SHIP_SPAWN_MAX = 16; // seconds',
        '  const BACKGROUND_SHIP_SPEED = 110;',
        '  const BACKGROUND_SHIP_RANGE = 420;',
        '  const BACKGROUND_SHIP_MAX_SHOTS = 3;',
        '  const BACKGROUND_SHIP_RADIUS = 12;',
        '  const audio = {',
        '    ctx: null, master: null, enabled: false, lastThrust: {},',
        '    init() {',
        '      if (this.ctx || typeof window === "undefined" || !(window.AudioContext || window.webkitAudioContext)) return;',
        '      try {',
        '        const Ctx = window.AudioContext || window.webkitAudioContext;',
        '        this.ctx = new Ctx();',
        '        this.master = this.ctx.createGain();',
        '        this.master.gain.value = 0.18;',
        '        this.master.connect(this.ctx.destination);',
        '        this.enabled = true;',
        '      } catch (e) { this.enabled = false; }',
        '    },',
        '    resume() { if (this.ctx && this.ctx.state === "suspended") this.ctx.resume(); },',
        '    play(frequency, duration, volume = 0.18, type = "square") {',
        '      if (!this.enabled || !this.ctx || !this.master) return;',
        '      const osc = this.ctx.createOscillator();',
        '      const gain = this.ctx.createGain();',
        '      osc.type = type;',
        '      osc.frequency.value = frequency;',
        '      gain.gain.setValueAtTime(volume, this.ctx.currentTime);',
        '      gain.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + duration);',
        '      osc.connect(gain); gain.connect(this.master);',
        '      osc.start(); osc.stop(this.ctx.currentTime + duration);',
        '    },',
        '    fire() { this.play(920, 0.08, 0.2, "square"); this.play(620, 0.12, 0.12, "sawtooth"); },',
        '    thrust(shipId) {',
        '      const now = performance.now();',
        '      const last = this.lastThrust[shipId] || 0;',
        '      if (now - last < 140) return;',
        '      this.lastThrust[shipId] = now;',
        '      this.play(170, 0.18, 0.14, "sawtooth");',
        '    },',
        '    explosion() { this.play(120, 0.4, 0.3, "triangle"); this.play(60, 0.32, 0.28, "sine"); },',
        '    impact() { this.play(340, 0.12, 0.18, "square"); },',
        '    star() { this.play(80, 0.5, 0.3, "sine"); this.play(40, 0.35, 0.22, "triangle"); }',
        '  };',
        '  let gravityScale = GRAVITY_MAX_SCALE;',
        '',
        '  let retroColorsEnabled = true;',
        '  const COLOR_PRESETS = {',
        "    normal: { alpha: '#0ff9ff', robot: '#ff5cff', asteroid: '#a89060', star: '#ffffff', overlayPrimary: '#0ff', overlayAlpha: '#0ff9ff', overlayRobot: '#ff5cff', flash: '#8cfff9' },",
        "    retro: { alpha: '#72ff72', robot: '#72ff72', asteroid: '#62d66f', star: '#9bff9b', overlayPrimary: '#72ff72', overlayAlpha: '#72ff72', overlayRobot: '#6aff7a', flash: '#7fff8a' }",
        '  };',
        '  function currentPalette() { return retroColorsEnabled ? COLOR_PRESETS.retro : COLOR_PRESETS.normal; }',
        '',
        '  const pointerState = {',
        '    pointerId: null,',
        '    pointerDown: false,',
        '    thrust: false,',
        '    fireQueued: false,',
        '    lastTap: 0,',
        '    downTime: 0,',
        '    aimX: null,',
        '    aimY: null',
        '  };',
        '',
        '  function randomRange(min, max) { return min + Math.random() * (max - min); }',
        '',
        '  function createBackgroundShipState() {',
        '    return {',
        '      active: false,',
        '      spawnTimer: randomRange(BACKGROUND_SHIP_SPAWN_MIN, BACKGROUND_SHIP_SPAWN_MAX),',
        '      x: 0,',
        '      y: 0,',
        '      baseY: 0,',
        '      vx: 0,',
        '      vy: 0,',
        '      angle: 0,',
        '      waveTimer: 0,',
        '      waveAmplitude: 12,',
        '      fireCooldown: 0,',
        '      activeShots: 0,',
        '      maxShots: BACKGROUND_SHIP_MAX_SHOTS,',
        '      score: 0,',
        "      label: 'Drifter',",
        '      color: currentPalette().overlayRobot',
        '    };',
        '  }',
        '',
        '  const mobileControlsState = {',
        '    container: null,',
        '    drag: {',
        '      active: false,',
        '      pointerId: null,',
        '      startX: 0,',
        '      startY: 0,',
        '      originLeft: 0,',
        '      originTop: 0,',
        '      width: 0,',
        '      height: 0',
        '    }',
        '  };',
        '',
        '  function setMobileControlsPosition(left, top) {',
        '    if (!mobileControlsState.container) return;',
        '    mobileControlsState.container.style.left = `${left}px`;',
        '    mobileControlsState.container.style.top = `${top}px`;',
        "    mobileControlsState.container.style.bottom = 'auto';",
        '  }',
        '',
        '  function clampMobilePosition(left, top, width, height) {',
        '    const padding = 8;',
        '    const maxLeft = Math.max(padding, (window.innerWidth || 0) - width - padding);',
        '    const maxTop = Math.max(padding, (window.innerHeight || 0) - height - padding);',
        '    return {',
        '      left: clamp(left, padding, maxLeft),',
        '      top: clamp(top, padding, maxTop)',
        '    };',
        '  }',
        '',
        '  function resetMobileControlsPosition() {',
        '    if (!mobileControlsState.container) return;',
        '    const rect = mobileControlsState.container.getBoundingClientRect();',
        '    const defaultLeft = 18;',
        '    const defaultTop = Math.max(18, (window.innerHeight || 0) - rect.height - 18);',
        '    setMobileControlsPosition(defaultLeft, defaultTop);',
        '  }',
        '',
        '  function isMobileDevice() {',
        "    return (window.matchMedia && window.matchMedia('(pointer:coarse)').matches) || /android|iphone|ipad|ipod|mobile/i.test(navigator.userAgent || '');",
        '  }',
        '',
        '  function setKey(code, isDown) {',
        '    if (isDown) {',
        '      game.keys[code] = true;',
        '    } else {',
        '      game.keys[code] = false;',
        '    }',
        '  }',
        '',
        '  function applyPaletteToEntities() {',
        '    const colors = currentPalette();',
        '    body.classList.toggle("retro-colors", retroColorsEnabled);',
        '    if (game && game.ships) {',
        '      game.ships.forEach((ship) => {',
        "        ship.color = ship.id === 'alpha' ? colors.alpha : colors.robot;",
        '        if (ship.lastExplosion) ship.lastExplosion.color = ship.color;',
        '      });',
        '    }',
        '    if (game && game.backgroundShip) { game.backgroundShip.color = colors.overlayRobot; }',
        '    if (game && game.projectiles) {',
        '      game.projectiles.forEach((shot) => {',
        "        shot.color = shot.owner ? shot.owner.color : colors.alpha;",
        '      });',
        '    }',
        '    if (game && game.debris) {',
        '      game.debris.forEach((d) => {',
        "        if (d.source === 'asteroid') d.color = colors.asteroid;",
        "        else if (d.ownerId) d.color = d.ownerId === 'alpha' ? colors.alpha : colors.robot;",
        '      });',
        '    }',
        '  }',
        '',
        '  function attachMobileControls() {',
        "    const container = document.querySelector('[data-mobile-controls]');",
        '    if (!container) return;',
        '    mobileControlsState.container = container;',
        '    body.classList.add(' + "'mobile-controls-active'" + ');',
        '    container.style.display = "grid";',
        '    resetMobileControlsPosition();',
        "    const alphaShip = () => game.ships.find((s) => s.id === 'alpha');",
        '    const press = (code, action, active) => {',
        '      if (mobileControlsState.drag.active) return;',
        '      if (action === "hyperspace") {',
        '        if (active) { const alpha = alphaShip(); if (alpha) attemptHyperspace(alpha); }',
        '        return;',
        '      }',
        '      setKey(code, active);',
        '      if (!active && action === "fire") { setTimeout(() => setKey(code, false), 10); }',
        '    };',
        '    const handleDragMove = (e) => {',
        '      if (!mobileControlsState.drag.pointerId || mobileControlsState.drag.pointerId !== e.pointerId) return;',
        '      const dx = e.clientX - mobileControlsState.drag.startX;',
        '      const dy = e.clientY - mobileControlsState.drag.startY;',
        '      const movedEnough = Math.hypot(dx, dy) > 6;',
        '      if (mobileControlsState.drag.active || movedEnough) {',
        '        if (!mobileControlsState.drag.active) {',
        '          mobileControlsState.drag.active = true;',
        '        }',
        '        const desiredLeft = mobileControlsState.drag.originLeft + dx;',
        '        const desiredTop = mobileControlsState.drag.originTop + dy;',
        '        const clamped = clampMobilePosition(desiredLeft, desiredTop, mobileControlsState.drag.width, mobileControlsState.drag.height);',
        '        setMobileControlsPosition(clamped.left, clamped.top);',
        '        e.preventDefault();',
        '      }',
        '    };',
        '    const handleDragEnd = (e) => {',
        '      if (!mobileControlsState.drag.pointerId || mobileControlsState.drag.pointerId !== e.pointerId) return;',
        '      if (mobileControlsState.drag.active) e.preventDefault();',
        '      mobileControlsState.drag.active = false;',
        '      mobileControlsState.drag.pointerId = null;',
        '      window.removeEventListener("pointermove", handleDragMove, { passive: false });',
        '      window.removeEventListener("pointerup", handleDragEnd, { passive: false });',
        '      window.removeEventListener("pointercancel", handleDragEnd, { passive: false });',
        '    };',
        '    const bind = (btn) => {',
        '      const code = btn.dataset.key;',
        '      const action = btn.dataset.action || "";',
        '      const onDown = (e) => {',
        '        e.preventDefault();',
        '        const rect = container.getBoundingClientRect();',
        '        mobileControlsState.drag.pointerId = e.pointerId;',
        '        mobileControlsState.drag.startX = e.clientX;',
        '        mobileControlsState.drag.startY = e.clientY;',
        '        mobileControlsState.drag.originLeft = rect.left;',
        '        mobileControlsState.drag.originTop = rect.top;',
        '        mobileControlsState.drag.width = rect.width;',
        '        mobileControlsState.drag.height = rect.height;',
        '        mobileControlsState.drag.active = false;',
        '        press(code, action, true);',
        '        window.addEventListener("pointermove", handleDragMove, { passive: false });',
        '        window.addEventListener("pointerup", handleDragEnd, { passive: false });',
        '        window.addEventListener("pointercancel", handleDragEnd, { passive: false });',
        '      };',
        '      const onUp = (e) => { e.preventDefault(); press(code, action, false); handleDragEnd(e); };',
        '      btn.addEventListener("pointerdown", onDown, { passive: false });',
        '      btn.addEventListener("pointerup", onUp, { passive: false });',
        '      btn.addEventListener("pointerleave", onUp, { passive: false });',
        '      btn.addEventListener("pointercancel", onUp, { passive: false });',
        '    };',
        "    container.querySelectorAll('button[data-key]').forEach(bind);",
        '    window.addEventListener("resize", () => {',
        '      const rect = container.getBoundingClientRect();',
        '      const clamped = clampMobilePosition(rect.left, rect.top, rect.width, rect.height);',
        '      setMobileControlsPosition(clamped.left, clamped.top);',
        '    });',
        '  }',
        '',
        '  const game = {',
        '    running: false,',
        '    countdown: 0,',
        '    lastTime: 0,',
        '    star: { x: 0, y: 0, radius: 28, mass: 70000, pulse: 0 },',
        '    ships: [],',
        '    projectiles: [],',
        '    asteroids: [],',
        '    debris: [],',
        '    backgroundShip: createBackgroundShipState(),',
        '    asteroidSpawnTimer: 0,',
        '    keys: {},',
        "    flashMessage: { text: '', timer: 0 },",
        '    settings: { winningScore: 7, livesPerRound: 3 },',
        '    round: 1,',
        '    nextRoundTimer: 0,',
        '    victoryAchieved: false',
        '  };',
        '',
        '  function clamp(value, min, max) { return Math.max(min, Math.min(max, value)); }',
        '  function normalizeAngle(angle) { return Math.atan2(Math.sin(angle), Math.cos(angle)); }',
        '  function resetAiState(ship) {',
        '    if (!ship || !ship.isAI) return;',
        '    if (!ship.ai) {',
        '      ship.ai = { fireTimer: 0, evasiveTimer: 0, strafeTimer: 0.8, strafeDir: Math.random() > 0.5 ? 1 : -1, hyperspaceWindow: 0 };',
        '      return;',
        '    }',
        '    ship.ai.fireTimer = 0;',
        '    ship.ai.evasiveTimer = 0;',
        '    ship.ai.strafeTimer = 0.8 + Math.random() * 0.6;',
        '    ship.ai.strafeDir = Math.random() > 0.5 ? 1 : -1;',
        '    ship.ai.hyperspaceWindow = 0;',
        '  }',
        '  function buildShip(id, label, color, controls, extra = {}) {',
        "    const normalizedControls = {};",
        "    Object.entries(controls || {}).forEach(([key, value]) => { normalizedControls[key] = Array.isArray(value) ? value : [value]; });",
        "    ['left', 'right', 'thrust', 'fire', 'hyperspace'].forEach((key) => { if (!normalizedControls[key]) normalizedControls[key] = []; });",
        "    const isAI = Boolean(extra.isAI);",
        "    return {",
        "      id,",
        "      label,",
        "      color,",
        "      controls: normalizedControls,",
        "      isAI,",
        "      ai: isAI ? { fireTimer: 0, evasiveTimer: 0, strafeTimer: 0.8, strafeDir: Math.random() > 0.5 ? 1 : -1, hyperspaceWindow: 0 } : null,",
        "      x: 0, y: 0, vx: 0, vy: 0,",
        "      angle: id === 'alpha' ? 0 : Math.PI,",
        "      radius: 16,",
        "      turnRate: Math.PI * 1.45,",
        "      thrustPower: 240,",
        "      cooldown: 0,",
        "      activeShots: 0,",
        '      maxShots: 4,',
        '      lives: game.settings.livesPerRound,',
        '      score: 0,',
        '      invulnerableTime: 0,',
        '      hyperspaceCooldown: 0,',
        '      thrusting: false,',
        "      respawnTimer: 0,",
        "      damage: 0,",
        "      damageParticles: [],",
        "      spawn: { x: 0, y: 0, angle: id === 'alpha' ? 0 : Math.PI },",
        "      lastExplosion: null",
        "    };",
        "  }",
        "  function createShips() {",
        "    game.ships = [",
        '      buildShip(' + "'alpha', 'Alpha Vector', currentPalette().alpha, { left: 'KeyA', right: 'KeyD', thrust: 'KeyW', fire: 'KeyS', hyperspace: 'KeyX' }" + '),',
        '      buildShip(' + "'robot', 'Robo Vector', currentPalette().robot, {}, { isAI: true }" + '),',
        "    ];",
        "  }",
        "  function setOverlay({ visible = true, title, body } = {}) {",
        "    if (!overlay) return;",
        "    if (visible) {",
        "      overlay.classList.remove('is-hidden');",
        "      overlayTitle.textContent = title || 'Space War Game';",
        "      overlayBody.textContent = body || 'Use the mission controls to engage the simulation.';",
        "    } else {",
        "      overlay.classList.add('is-hidden');",
        "    }",
        "  }",
        "  function setSpawnPositions(applyToShips = false) {",
        "    const width = canvas.width || 960;",
        "    const height = canvas.height || 540;",
        "    game.ships.forEach((ship) => {",
        "      if (ship.id === 'alpha') {",
        "        ship.spawn.x = width * 0.12;",
        "        ship.spawn.y = height * 0.5;",
        "        ship.spawn.angle = 0;",
        '      } else {',
        '        ship.spawn.x = width * 0.88;',
        '        ship.spawn.y = height * 0.5;',
        '        ship.spawn.angle = Math.PI;',
        '      }',
        '      if (applyToShips) { ship.x = ship.spawn.x; ship.y = ship.spawn.y; ship.angle = ship.spawn.angle; }',
        '    });',
        '  }',
        '  function resizeCanvas() {',
        '    const rect = stage.getBoundingClientRect();',
        '    if (!rect.width || !rect.height) return;',
        '    let displayWidth = rect.width;',
        '    let displayHeight = rect.height;',
        '    const dpr = window.devicePixelRatio || 1;',
        '    const width = Math.max(200, Math.round(displayWidth * dpr));',
        '    const height = Math.max(200, Math.round(displayHeight * dpr));',
        '    canvas.style.width = `${displayWidth}px`;',
        '    canvas.style.height = `${displayHeight}px`;',
        '    if (canvas.width !== width || canvas.height !== height) { canvas.width = width; canvas.height = height; }',
        '    game.star.x = canvas.width / 2;',
        '    game.star.y = canvas.height / 2;',
        '    const minRadius = 14 * dpr;',
        '    const maxDimension = Math.min(canvas.width, canvas.height);',
        '    game.star.radius = Math.max(minRadius, maxDimension * 0.018);',
        '    setSpawnPositions(!game.running);',
        '  }',
        '  function refreshHud() {',
        '    const alpha = game.ships[0];',
        '    const robot = game.ships[1];',
        '    if (alpha) { scoreAlpha.textContent = alpha.score; livesAlpha.textContent = alpha.lives; }',
        '    if (robot) { scoreRobot.textContent = robot.score; livesRobot.textContent = robot.lives; }',
        '    roundIndicator.textContent = game.round;',
        '  }',
        '  function initializeGameState() {',
        '    game.victoryAchieved = false;',
        '    setSpawnPositions(false); // Ensure spawn positions are set before positioning ships',
        "    game.projectiles.length = 0; game.asteroids.length = 0; game.debris.length = 0; game.asteroidSpawnTimer = ASTEROID_SPAWN_INTERVAL;",
        '    resetBackgroundShip();',
        '    game.backgroundShip.color = currentPalette().overlayRobot;',
        "    game.round = 1; game.countdown = 0; game.nextRoundTimer = 0;",
        "    game.flashMessage.text = ''; game.flashMessage.timer = 0;",
        "    game.ships.forEach((ship) => {",
        "      ship.score = 0; ship.lives = game.settings.livesPerRound;",
        "      ship.vx = 0; ship.vy = 0; ship.angle = ship.spawn.angle; ship.x = ship.spawn.x; ship.y = ship.spawn.y;",
        "      ship.cooldown = 0; ship.invulnerableTime = 0; ship.hyperspaceCooldown = 0; ship.thrusting = false;",
        "      ship.respawnTimer = 0; ship.activeShots = 0; ship.lastExplosion = null; ship.damage = 0; ship.damageParticles = []; resetAiState(ship);",
        "    });",
        "    refreshHud();",
        "  }",
        "  function triggerMessage(text, duration = 1.8) { game.flashMessage.text = text; game.flashMessage.timer = duration; }",
        "  function startGame() {",
        "    if (game.running) return;",
        "    startButton.disabled = true; resetButton.disabled = false;",
        "    body.classList.add('playing'); wrapper.classList.add('playing');",
        "    canvas.focus();",
        "    setOverlay({ visible: false });",
        "    requestAnimationFrame(() => {",
        "      resizeCanvas(); setSpawnPositions(true); initializeGameState(); game.countdown = 1.2;",
        "      triggerMessage('Round 1: Stand by for vector combat', 1.8);",
        "        game.running = true; game.lastTime = performance.now();",
        '        audio.init(); audio.resume();',
        "    });",
        "  }",
        "  function stopGame({ title, message, resetScores = false } = {}) {",
        "    if (!game.running && !body.classList.contains('playing')) {",
        "      setOverlay({ visible: true, title, body: message }); return;",
        "    }",
        "    game.running = false; game.countdown = 0; game.nextRoundTimer = 0;",
        "    game.projectiles.length = 0; game.asteroids.length = 0; game.debris.length = 0; game.keys = {};",
        '    resetBackgroundShip();',
        "    body.classList.remove('playing'); wrapper.classList.remove('playing');",
        "    startButton.disabled = false; resetButton.disabled = true;",
        "    setOverlay({ visible: true, title, body: message });",
        "    game.lastTime = performance.now();",
        "    if (resetScores) {",
        "      requestAnimationFrame(() => { resizeCanvas(); initializeGameState(); });",
        "    } else { requestAnimationFrame(resizeCanvas); }",
        "  }",
        "  function wrapPosition(entity) {",
        '    if (entity.x < 0) entity.x += canvas.width;',
        '    else if (entity.x > canvas.width) entity.x -= canvas.width;',
        '    if (entity.y < 0) entity.y += canvas.height;',
        '    else if (entity.y > canvas.height) entity.y -= canvas.height;',
        '  }',
        '  function resetBackgroundShip(keepTimer = false) {',
        '    const npc = game.backgroundShip;',
        '    if (!npc) return;',
        '    npc.active = false;',
        '    npc.activeShots = 0;',
        '    npc.fireCooldown = 0;',
        '    npc.waveTimer = 0;',
        '    npc.waveAmplitude = 12;',
        '    npc.spawnTimer = keepTimer ? npc.spawnTimer : randomRange(BACKGROUND_SHIP_SPAWN_MIN, BACKGROUND_SHIP_SPAWN_MAX);',
        '  }',
        '  function spawnBackgroundShip() {',
        '    const npc = game.backgroundShip;',
        '    const width = canvas.width || 960;',
        '    const height = canvas.height || 540;',
        '    const fromLeft = Math.random() > 0.5;',
        '    const margin = 60;',
        '    npc.active = true;',
        '    npc.activeShots = 0;',
        '    npc.spawnTimer = randomRange(BACKGROUND_SHIP_SPAWN_MIN * 0.5, BACKGROUND_SHIP_SPAWN_MIN * 0.85);',
        '    npc.baseY = clamp(height * (0.18 + Math.random() * 0.64), 32, height - 32);',
        '    npc.waveAmplitude = 10 + Math.random() * 18;',
        '    npc.waveTimer = 0;',
        '    npc.x = fromLeft ? -margin : width + margin;',
        '    npc.y = npc.baseY;',
        '    npc.vx = (fromLeft ? 1 : -1) * BACKGROUND_SHIP_SPEED;',
        '    npc.vy = 0;',
        '    npc.angle = fromLeft ? 0 : Math.PI;',
        '    npc.fireCooldown = 0.4 + Math.random() * 0.4;',
        '  }',
        '  function findBackgroundTarget(npc) {',
        '    let best = null;',
        '    const candidates = [];',
        '    for (const ship of game.ships) {',
        '      if (ship.lives > 0 && ship.respawnTimer <= 0 && ship.invulnerableTime <= 0) {',
        '        candidates.push({ entity: ship, vx: ship.vx, vy: ship.vy });',
        '      }',
        '    }',
        '    for (const ast of game.asteroids) { candidates.push({ entity: ast, vx: ast.vx, vy: ast.vy }); }',
        '    for (const item of candidates) {',
        '      const dx = item.entity.x - npc.x;',
        '      const dy = item.entity.y - npc.y;',
        '      const distance = Math.hypot(dx, dy);',
        '      if (distance > BACKGROUND_SHIP_RANGE) continue;',
        '      if (!best || distance < best.distance) { best = { ...item, distance }; }',
        '    }',
        '    return best;',
        '  }',
        '  function fireBackgroundShot(npc, target) {',
        '    if (!target || npc.fireCooldown > 0 || npc.activeShots >= npc.maxShots) return;',
        '    const leadTime = clamp(target.distance / (SHOT_SPEED * 0.85), 0.12, 1.05);',
        '    const predictedX = target.entity.x + (target.vx || 0) * leadTime;',
        '    const predictedY = target.entity.y + (target.vy || 0) * leadTime;',
        '    const heading = Math.atan2(predictedY - npc.y, predictedX - npc.x);',
        '    const speed = SHOT_SPEED * 0.9;',
        '    const color = npc.color || currentPalette().overlayRobot;',
        '    const shot = {',
        '      x: npc.x + Math.cos(heading) * 12,',
        '      y: npc.y + Math.sin(heading) * 12,',
        '      vx: Math.cos(heading) * speed,',
        '      vy: Math.sin(heading) * speed,',
        '      life: 2.1,',
        '      color: color,',
        '      owner: npc,',
        '      heading: heading',
        '    };',
        '    npc.activeShots = Math.min(npc.maxShots, npc.activeShots + 1);',
        '    npc.fireCooldown = 1 + Math.random() * 0.7;',
        '    game.projectiles.push(shot);',
        '    audio.fire();',
        '  }',
        '  function spawnBackgroundDebris(npc) {',
        '    const fragments = 7 + Math.floor(Math.random() * 4);',
        '    const color = npc.color || currentPalette().overlayRobot;',
        '    for (let i = 0; i < fragments; i++) {',
        '      const angle = Math.random() * Math.PI * 2;',
        '      const speed = 60 + Math.random() * 40;',
        '      const size = BACKGROUND_SHIP_RADIUS * (0.2 + Math.random() * 0.25);',
        '      const verts = [];',
        '      const vertsCount = 4 + Math.floor(Math.random() * 3);',
        '      for (let v = 0; v < vertsCount; v++) {',
        '        const a = (v / vertsCount) * Math.PI * 2;',
        '        const r = size * (0.6 + Math.random() * 0.4);',
        '        verts.push([Math.cos(a) * r, Math.sin(a) * r]);',
        '      }',
        '      game.debris.push({',
        '        x: npc.x,',
        '        y: npc.y,',
        '        vx: npc.vx * 0.3 + Math.cos(angle) * speed,',
        '        vy: npc.vy * 0.3 + Math.sin(angle) * speed,',
        '        angle: npc.angle,',
        '        spin: (Math.random() - 0.5) * 8,',
        '        segments: verts,',
        '        color,',
        "        source: 'backgroundShip',",
        '        life: 1.2,',
        '        maxLife: 1.2',
        '      });',
        '    }',
        '  }',
        '  function destroyBackgroundShip(attacker) {',
        '    const npc = game.backgroundShip;',
        '    if (!npc || !npc.active) return;',
        '    spawnBackgroundDebris(npc);',
        '    npc.active = false;',
        '    npc.activeShots = 0;',
        '    npc.fireCooldown = 0;',
        '    npc.spawnTimer = randomRange(BACKGROUND_SHIP_SPAWN_MIN, BACKGROUND_SHIP_SPAWN_MAX);',
        '    audio.explosion();',
        '    if (attacker && attacker !== npc && attacker.score !== undefined) { attacker.score += 1; refreshHud(); }',
        "    const label = attacker && attacker.label ? attacker.label : 'A stray shot';",
        '    triggerMessage(`${label} scrapped the drifter`, 1.8);',
        '  }',
        '  function updateBackgroundShip(dt, activePhase) {',
        '    const npc = game.backgroundShip;',
        '    if (!npc) return;',
        '    if (!npc.active) {',
        '      npc.spawnTimer = Math.max(0, npc.spawnTimer - dt);',
        '      if (activePhase && npc.spawnTimer === 0) { spawnBackgroundShip(); }',
        '      return;',
        '    }',
        '    npc.waveTimer += dt * 1.6;',
        '    npc.x += npc.vx * dt;',
        '    npc.y = npc.baseY + Math.sin(npc.waveTimer) * npc.waveAmplitude;',
        '    npc.angle = npc.vx >= 0 ? 0 : Math.PI;',
        '    npc.fireCooldown = Math.max(0, npc.fireCooldown - dt);',
        '    if (activePhase && npc.activeShots < npc.maxShots) {',
        '      const target = findBackgroundTarget(npc);',
        '      if (target && target.distance <= BACKGROUND_SHIP_RANGE && npc.fireCooldown === 0) { fireBackgroundShot(npc, target); }',
        '    }',
        '    const width = canvas.width || 960;',
        '    const margin = 90;',
        '    if ((npc.vx > 0 && npc.x > width + margin) || (npc.vx < 0 && npc.x < -margin)) {',
        '      resetBackgroundShip();',
        '      npc.spawnTimer = randomRange(BACKGROUND_SHIP_SPAWN_MIN, BACKGROUND_SHIP_SPAWN_MAX);',
        '    }',
        '  }',
        '  function fireShot(ship) {',
        '    if (ship.cooldown > 0 || ship.activeShots >= ship.maxShots || ship.respawnTimer > 0 || ship.lives <= 0) return;',
        '    const speed = SHOT_SPEED;',
        '    const cos = Math.cos(ship.angle), sin = Math.sin(ship.angle);',
        '    const shot = { x: ship.x + cos * (ship.radius + 2), y: ship.y + sin * (ship.radius + 2),',
        '      vx: Math.cos(ship.angle) * speed, vy: Math.sin(ship.angle) * speed, life: 1.9, color: ship.color, owner: ship, heading: ship.angle };',
        '    ship.cooldown = 0.28; ship.activeShots += 1; game.projectiles.push(shot);',
        '    audio.fire();',
        '  }',
        '  function getOpponent(ship) { return game.ships.find((other) => other !== ship); }',
        '  function computeAiIntent(ship, dt) {',
        '    const intent = { thrust: false, left: false, right: false, fire: false };',
        '    const opponent = getOpponent(ship);',
        '    if (!opponent || opponent.lives <= 0) return intent;',
        '    const ai = ship.ai || (ship.ai = { fireTimer: 0, evasiveTimer: 0, strafeTimer: 0.8, strafeDir: Math.random() > 0.5 ? 1 : -1, hyperspaceWindow: 0 });',
        '    ai.fireTimer = Math.max(0, ai.fireTimer - dt);',
        '    ai.evasiveTimer = Math.max(0, ai.evasiveTimer - dt);',
        '    ai.hyperspaceWindow = Math.max(0, ai.hyperspaceWindow - dt);',
        '    ai.strafeTimer = Math.max(0, ai.strafeTimer - dt);',
        '    const dx = opponent.x - ship.x, dy = opponent.y - ship.y;',
        '    const distance = Math.hypot(dx, dy) || 1;',
        '    const relativeVx = opponent.vx - ship.vx;',
        '    const relativeVy = opponent.vy - ship.vy;',
        '    const leadTime = clamp(distance / SHOT_SPEED, 0.08, 1.3);',
        '    const targetX = opponent.x + relativeVx * leadTime;',
        '    const targetY = opponent.y + relativeVy * leadTime;',
        '    const targetAngle = Math.atan2(targetY - ship.y, targetX - ship.x);',
        '    const aimingDiff = normalizeAngle(targetAngle - ship.angle);',
        '    const turnAllowance = 0.05 + (distance < 220 ? 0.02 : 0);',
        '    if (aimingDiff > turnAllowance) intent.right = true;',
        '    else if (aimingDiff < -turnAllowance) intent.left = true;',
        '    const starDx = ship.x - game.star.x, starDy = ship.y - game.star.y;',
        '    const starDistance = Math.hypot(starDx, starDy);',
        '    if (starDistance < game.star.radius + 120) { ai.evasiveTimer = Math.max(ai.evasiveTimer, 1.05); }',
        '    if (ai.evasiveTimer > 0) {',
        '      const escapeAngle = Math.atan2(ship.y - game.star.y, ship.x - game.star.x);',
        '      const escapeDiff = normalizeAngle(escapeAngle - ship.angle);',
        '      if (escapeDiff > 0.06) { intent.right = true; intent.left = false; }',
        '      else if (escapeDiff < -0.06) { intent.left = true; intent.right = false; }',
        '      else { intent.left = false; intent.right = false; }',
        '      intent.thrust = true;',
        '      if (starDistance < game.star.radius + 72 && ship.hyperspaceCooldown <= 0 && ai.hyperspaceWindow === 0) {',
        '        attemptHyperspace(ship); ai.hyperspaceWindow = 4;',
        '      }',
        '    } else {',
        '      const preferredDistance = 260;',
        '      if (distance > preferredDistance + 70) { intent.thrust = true; }',
        '      else if (distance < preferredDistance * 0.6) {',
        '        intent.thrust = false;',
        '        if (Math.abs(aimingDiff) < 0.4) { if (ai.strafeDir > 0) intent.right = true; else intent.left = true; }',
        '      } else if (Math.abs(aimingDiff) < 0.35) { intent.thrust = true; }',
        '      if (ai.strafeTimer === 0) { ai.strafeTimer = 1.2 + Math.random() * 1.6; ai.strafeDir = Math.random() > 0.5 ? 1 : -1; }',
        '      if (Math.abs(aimingDiff) < 0.8 && distance < 520) { if (ai.strafeDir > 0) intent.right = true; else intent.left = true; }',
        '    }',
        '    const targetStarDx = targetX - game.star.x, targetStarDy = targetY - game.star.y;',
        '    const targetNearStar = Math.hypot(targetStarDx, targetStarDy) < game.star.radius + 40;',
        '    if (Math.abs(aimingDiff) < 0.18 && ai.fireTimer === 0 && distance < 540 && !targetNearStar) {',
        '      intent.fire = true; ai.fireTimer = 0.24 + Math.random() * 0.26;',
        '    }',
        '    if (intent.left && intent.right) {',
        '      if (Math.abs(aimingDiff) <= 0.04) { intent.left = false; intent.right = false; }',
        '      else if (aimingDiff > 0) intent.left = false; else intent.right = false;',
        '    }',
        '    return intent;',
        '  }',
        '  function resolveShipIntent(ship, dt) {',
        '    if (ship.isAI) return computeAiIntent(ship, dt);',
        '    const intent = {',
        '      thrust: ship.controls.thrust.some((code) => game.keys[code]),',
        '      left: ship.controls.left.some((code) => game.keys[code]),',
        '      right: ship.controls.right.some((code) => game.keys[code]),',
        "      fire: ship.controls.fire.some((code) => game.keys[code])",
        "    };",
        "    if (ship.id === 'alpha') {",
        "      intent.thrust = intent.thrust || pointerState.thrust;",
        "      if (pointerState.fireQueued) { intent.fire = true; pointerState.fireQueued = false; }",
        "      if (pointerState.pointerDown && pointerState.aimX !== null && pointerState.aimY !== null) {",
        "        ship.angle = normalizeAngle(Math.atan2(pointerState.aimY - ship.y, pointerState.aimX - ship.x));",
        "        intent.left = false; intent.right = false;",
        '      }',
        '    }',
        '    return intent;',
        '  }',
        '  function spawnDamageParticle(ship) {',
        '    const angle = Math.random() * Math.PI * 2;',
        '    const speed = 15 + Math.random() * 25;',
        '    ship.damageParticles.push({',
        '      x: ship.x + (Math.random() - 0.5) * ship.radius * 0.8,',
        '      y: ship.y + (Math.random() - 0.5) * ship.radius * 0.8,',
        '      vx: ship.vx * 0.5 + Math.cos(angle) * speed,',
        '      vy: ship.vy * 0.5 + Math.sin(angle) * speed,',
        '      life: 0.4 + Math.random() * 0.3,',
        '      size: 1.5 + Math.random() * 2',
        '    });',
        '  }',
        '  function spawnSputter(ship) {',
        '    // Spawn a bright spark from damaged area - looks like engine misfire',
        '    const isAlpha = ship.id === "alpha";',
        '    const r = isAlpha ? ship.radius : ship.radius * ROBOT_SHIP_SCALE;',
        '    // Emit from back of ship (damaged engine area)',
        '    const emitX = ship.x + Math.cos(ship.angle + Math.PI) * r * 0.7;',
        '    const emitY = ship.y + Math.sin(ship.angle + Math.PI) * r * 0.7;',
        '    // Sparks shoot out backwards with some randomness',
        '    const spreadAngle = ship.angle + Math.PI + (Math.random() - 0.5) * 1.2;',
        '    const speed = 40 + Math.random() * 60;',
        '    ship.damageParticles.push({',
        '      x: emitX + (Math.random() - 0.5) * r * 0.3,',
        '      y: emitY + (Math.random() - 0.5) * r * 0.3,',
        '      vx: ship.vx * 0.3 + Math.cos(spreadAngle) * speed,',
        '      vy: ship.vy * 0.3 + Math.sin(spreadAngle) * speed,',
        '      life: 0.15 + Math.random() * 0.25,',
        '      size: 1.0 + Math.random() * 1.5,',
        '      isSpark: true',
        '    });',
        '  }',
        '  function spawnDebris(ship, damageLevel) {',
        '    // Spawn ejected ship fragment with glowing plasma effect',
        '    const ejectAngle = ship.angle + Math.PI + (Math.random() - 0.5) * 0.8;',
        '    const ejectSpeed = 60 + Math.random() * 40;',
        '    const spinRate = (Math.random() - 0.5) * 8;',
        '    // Create debris based on ship type and damage level',
        '    const isAlpha = ship.id === "alpha";',
        '    const r = isAlpha ? ship.radius : ship.radius * ROBOT_SHIP_SCALE;',
        '    let segments = [];',
        '    if (isAlpha) {',
        '      if (damageLevel === 1) {',
        '        // Half of top-right side',
        '        segments = [[r * 0.15, r * 0.3], [-r * 0.3, r * 0.45], [-r * 0.75, r * 0.6], [r * 0.15, r * 0.3]];',
        '      } else if (damageLevel === 2) {',
        '        // Rest of side + half back',
        '        segments = [[-r * 0.3, r * 0.45], [-r * 0.75, r * 0.6], [-r * 0.65, r * 0.3], [-r * 0.55, 0], [-r * 0.3, r * 0.45]];',
        '      }',
        '    } else {',
        '      // Enterprise nacelle pieces',
        '      const saucerR = r * 0.65;',
        '      const neckLen = r * 0.45;',
        '      const nacelleLen = r * 0.7;',
        '      const nacelleGap = r * 0.45;',
        '      const nacelleStartX = -saucerR * 0.6 - neckLen;',
        '      const nacelleEndX = nacelleStartX - nacelleLen;',
        '      if (damageLevel === 1) {',
        '        // Front half of nacelle (with engine pod)',
        '        const midX = nacelleStartX - nacelleLen * 0.5;',
        '        segments = [[midX, nacelleGap], [nacelleEndX, nacelleGap], [nacelleEndX, nacelleGap + r * 0.18], [nacelleEndX, nacelleGap - r * 0.18], [midX, nacelleGap]];',
        '      } else if (damageLevel === 2) {',
        '        // Back half of nacelle (pylon stub)',
        '        const midX = nacelleStartX - nacelleLen * 0.5;',
        '        segments = [[nacelleStartX, nacelleGap], [midX, nacelleGap], [midX, nacelleGap + r * 0.08], [nacelleStartX, nacelleGap]];',
        '      }',
        '    }',
        '    if (segments.length > 0) {',
        '      game.debris.push({',
        '        x: ship.x,',
        '        y: ship.y,',
        '        vx: ship.vx * 0.3 + Math.cos(ejectAngle) * ejectSpeed,',
        '        vy: ship.vy * 0.3 + Math.sin(ejectAngle) * ejectSpeed,',
        '        angle: ship.angle,',
        '        spin: spinRate,',
        '        segments: segments,',
        '        color: ship.color,',
        "        ownerId: ship.id,",
        "        source: 'ship',",
        '        life: 1.2,',
        '        maxLife: 1.2',
        '      });',
        '    }',
        '  }',
        '  function applyDamage(ship, attacker, cause) {',
        '    if (ship.respawnTimer > 0 || ship.invulnerableTime > 0 || game.victoryAchieved) return;',
        '    ship.damage += 1;',
        '    ship.invulnerableTime = 0.25;',
        '    // Spawn debris for the damaged piece',
        '    spawnDebris(ship, ship.damage);',
        '    audio.impact();',
        '    if (ship.damage >= 3) {',
        '      processDestruction(ship, attacker, cause);',
        '      ship.damage = 0; ship.damageParticles = [];',
        '    } else {',
        '      triggerMessage(`${ship.label} hit! (${3 - ship.damage} hits remaining)`, 1.2);',
        '    }',
        '  }',
        '  function processDestruction(ship, attacker, cause) {',
        '    if (ship.respawnTimer > 0 || game.victoryAchieved) return;',
        '    const opponent = getOpponent(ship);',
        '    ship.lastExplosion = { x: ship.x, y: ship.y, timer: 0.45, color: ship.color };',
        '    ship.respawnTimer = 1.35; ship.thrusting = false;',
        '    if (cause === "the gravity well") { audio.star(); } else { audio.explosion(); }',
        '    if (attacker && attacker !== ship) attacker.score += 1;',
        '    else if (opponent) opponent.score += 1;',
        '    ship.lives = Math.max(0, ship.lives - 1);',
        '    refreshHud();',
        '    if (attacker && attacker !== ship) triggerMessage(`${attacker.label} scores via ${cause}`, 2.1);',
        '    else triggerMessage(`${ship.label} lost to ${cause}`, 2.1);',
        '    checkVictory();',
        '    if (game.victoryAchieved) return;',
        '    if (ship.lives <= 0 && game.nextRoundTimer === 0) {',
        '      game.nextRoundTimer = 2.6; triggerMessage(`Round ${game.round + 1} recalibrating`, 2.4);',
        '    }',
        '  }',
        '  function resetRound() {',
        '    game.round += 1; game.projectiles.length = 0; game.asteroids.length = 0; game.debris.length = 0; game.asteroidSpawnTimer = ASTEROID_SPAWN_INTERVAL;',
        '    game.ships.forEach((ship) => {',
        '      ship.lives = game.settings.livesPerRound; ship.vx = 0; ship.vy = 0;',
        '      ship.x = ship.spawn.x; ship.y = ship.spawn.y; ship.angle = ship.spawn.angle;',
        '      ship.cooldown = 0; ship.invulnerableTime = 1.2; ship.hyperspaceCooldown = Math.max(0, ship.hyperspaceCooldown - 1);',
        '      ship.thrusting = false; ship.respawnTimer = 0; ship.activeShots = 0; ship.damage = 0; ship.damageParticles = []; resetAiState(ship);',
        '    });',
        '    refreshHud(); game.countdown = 1.2; game.nextRoundTimer = 0;',
        '  }',
        '  function attemptHyperspace(ship) {',
        '    if (ship.hyperspaceCooldown > 0 || ship.respawnTimer > 0 || ship.lives <= 0 || game.countdown > 0 || game.nextRoundTimer > 0) return;',
        '    ship.x = Math.random() * canvas.width; ship.y = Math.random() * canvas.height;',
        "    ship.vx = 0; ship.vy = 0; ship.invulnerableTime = 1.5; ship.hyperspaceCooldown = 5;",
        "    if (Math.random() < 0.18) { processDestruction(ship, null, 'hyperspace malfunction'); }",
        "    else { triggerMessage(`${ship.label} slips through hyperspace`, 1.4); }",
        "  }",
        "  function checkVictory() {",
        "    if (game.victoryAchieved) return;",
        "    const winner = game.ships.find((ship) => ship.score >= game.settings.winningScore);",
        "    if (winner) {",
        "      game.victoryAchieved = true;",
        "      stopGame({ title: `${winner.label} reigns supreme`, message: `${winner.label} reached ${game.settings.winningScore} vector victories. Engage again to relive the battle.`, resetScores: false });",
        "    }",
        "  }",
        "  function releaseShot(shot, index) {",
        "    if (shot.owner) shot.owner.activeShots = Math.max(0, shot.owner.activeShots - 1);",
        '    game.projectiles.splice(index, 1);',
        '  }',
        '  function updateProjectiles(dt, activePhase) {',
        '    for (let i = game.projectiles.length - 1; i >= 0; i -= 1) {',
        '      const shot = game.projectiles[i];',
        '      shot.life -= dt;',
        '      if (shot.life <= 0) { releaseShot(shot, i); continue; }',
        '      if (activePhase) {',
        '        shot.x += shot.vx * dt; shot.y += shot.vy * dt;',
        '        if (shot.x < 0) shot.x += canvas.width; else if (shot.x > canvas.width) shot.x -= canvas.width;',
        '        if (shot.y < 0) shot.y += canvas.height; else if (shot.y > canvas.height) shot.y -= canvas.height;',
        '      }',
        '      const dxStar = shot.x - game.star.x, dyStar = shot.y - game.star.y;',
        '      if (Math.hypot(dxStar, dyStar) < game.star.radius) { releaseShot(shot, i); continue; }',
        '      const npc = game.backgroundShip;',
        '      if (npc && npc.active && shot.owner !== npc) {',
        '        const dxNpc = shot.x - npc.x;',
        '        const dyNpc = shot.y - npc.y;',
        '        if (Math.hypot(dxNpc, dyNpc) < BACKGROUND_SHIP_RADIUS) { destroyBackgroundShip(shot.owner); releaseShot(shot, i); continue; }',
        '      }',
        '      for (const ship of game.ships) {',
        '        if (ship === shot.owner || ship.respawnTimer > 0 || ship.lives <= 0 || ship.invulnerableTime > 0) continue;',
        "        const dx = shot.x - ship.x, dy = shot.y - ship.y;",
        "        if (Math.hypot(dx, dy) < ship.radius * 0.85) { applyDamage(ship, shot.owner, 'torpedo impact'); releaseShot(shot, i); break; }",
        '      }',
        '    }',
        '  }',
        '  function respawnShip(ship) {',
        '    if (ship.lives <= 0 || game.victoryAchieved || game.nextRoundTimer > 0) return;',
        '    ship.x = ship.spawn.x + (Math.random() - 0.5) * ship.radius * 2;',
        '    ship.y = ship.spawn.y + (Math.random() - 0.5) * ship.radius * 2;',
        '    ship.vx = 0; ship.vy = 0; ship.angle = ship.spawn.angle; ship.invulnerableTime = 1.5; ship.respawnTimer = 0;',
        '    ship.damage = 0; ship.damageParticles = []; resetAiState(ship);',
        '  }',
        '  // Asteroid system',
        '  const ASTEROID_SPAWN_INTERVAL = 3; // seconds between spawn attempts',
        '  const ASTEROID_SPAWN_CHANCE = 1.0; // 100% chance per attempt (guaranteed spawn)',
        '  const ASTEROID_MIN_RADIUS = 18;',
        '  const ASTEROID_MAX_RADIUS = 45;',
        '  const ASTEROID_SPLIT_MIN = 12;',
        '  function createAsteroid(x, y, vx, vy, radius) {',
        '    const vertices = [];',
        '    const numVerts = 8 + Math.floor(Math.random() * 4);',
        '    for (let i = 0; i < numVerts; i++) {',
        '      const angle = (i / numVerts) * Math.PI * 2;',
        '      const r = radius * (0.7 + Math.random() * 0.5);',
        '      vertices.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });',
        '    }',
        '    return { x, y, vx, vy, radius, vertices, rotation: 0, rotationSpeed: (Math.random() - 0.5) * 1.5 };',
        '  }',
        '  function spawnAsteroid() {',
        '    if (game.asteroids.length >= 3) return; // max 3 asteroids at once',
        '    const edge = Math.floor(Math.random() * 4);',
        '    let x, y, vx, vy;',
        '    const speed = 40 + Math.random() * 60;',
        '    const radius = ASTEROID_MIN_RADIUS + Math.random() * (ASTEROID_MAX_RADIUS - ASTEROID_MIN_RADIUS);',
        '    if (edge === 0) { x = -radius; y = Math.random() * canvas.height; vx = speed; vy = (Math.random() - 0.5) * speed; }',
        '    else if (edge === 1) { x = canvas.width + radius; y = Math.random() * canvas.height; vx = -speed; vy = (Math.random() - 0.5) * speed; }',
        '    else if (edge === 2) { x = Math.random() * canvas.width; y = -radius; vx = (Math.random() - 0.5) * speed; vy = speed; }',
        '    else { x = Math.random() * canvas.width; y = canvas.height + radius; vx = (Math.random() - 0.5) * speed; vy = -speed; }',
        '    game.asteroids.push(createAsteroid(x, y, vx, vy, radius));',
        '  }',
        '  function spawnAsteroidDebris(asteroid) {',
        '    // Spawn 3-5 rock fragments flying outward from impact',
        '    const colors = currentPalette();',
        '    const numFragments = 3 + Math.floor(Math.random() * 3);',
        '    for (let i = 0; i < numFragments; i++) {',
        '      const angle = Math.random() * Math.PI * 2;',
        '      const speed = 30 + Math.random() * 50;',
        '      const size = asteroid.radius * (0.15 + Math.random() * 0.2);',
        '      // Create small rocky polygon',
        '      const segments = [];',
        '      const verts = 4 + Math.floor(Math.random() * 2);',
        '      for (let v = 0; v < verts; v++) {',
        '        const a = (v / verts) * Math.PI * 2;',
        '        const r = size * (0.6 + Math.random() * 0.4);',
        '        segments.push([Math.cos(a) * r, Math.sin(a) * r]);',
        '      }',
        '      game.debris.push({',
        '        x: asteroid.x,',
        '        y: asteroid.y,',
        '        vx: asteroid.vx * 0.3 + Math.cos(angle) * speed,',
        '        vy: asteroid.vy * 0.3 + Math.sin(angle) * speed,',
        '        angle: Math.random() * Math.PI * 2,',
        '        spin: (Math.random() - 0.5) * 6,',
        '        segments: segments,',
        "        color: colors.asteroid,",
        "        source: 'asteroid',",
        '        life: 0.8 + Math.random() * 0.4,',
        '        maxLife: 1.2',
        '      });',
        '    }',
        '  }',
        '  function splitAsteroid(asteroid, index) {',
        '    // Spawn impact debris before removing',
        '    spawnAsteroidDebris(asteroid);',
        '    game.asteroids.splice(index, 1);',
        '    if (asteroid.radius < ASTEROID_SPLIT_MIN * 1.5) return; // too small to split',
        '    const newRadius = asteroid.radius * 0.55;',
        '    if (newRadius < ASTEROID_SPLIT_MIN) return;',
        '    const spreadAngle = Math.random() * Math.PI * 2;',
        '    const spreadSpeed = 35 + Math.random() * 25;',
        '    game.asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.vx + Math.cos(spreadAngle) * spreadSpeed, asteroid.vy + Math.sin(spreadAngle) * spreadSpeed, newRadius));',
        '    game.asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.vx - Math.cos(spreadAngle) * spreadSpeed, asteroid.vy - Math.sin(spreadAngle) * spreadSpeed, newRadius));',
        '  }',
        '  function updateAsteroids(dt, activePhase) {',
        '    // Spawn timer',
        '    if (activePhase && game.asteroids.length < 3) {',
        '      game.asteroidSpawnTimer -= dt;',
        '      if (game.asteroidSpawnTimer <= 0) {',
        '        game.asteroidSpawnTimer = ASTEROID_SPAWN_INTERVAL;',
        '        if (Math.random() < ASTEROID_SPAWN_CHANCE) spawnAsteroid();',
        '      }',
        '    }',
        '    for (let i = game.asteroids.length - 1; i >= 0; i--) {',
        '      const ast = game.asteroids[i];',
        '      if (!ast || typeof ast.x !== "number" || typeof ast.y !== "number" || typeof ast.radius !== "number" || !Array.isArray(ast.vertices) || ast.vertices.length === 0 || !ast.vertices[0]) {',
        '        game.asteroids.splice(i, 1);',
        '        continue;',
        '      }',
        '      if (activePhase) {',
        '        // Apply gravity from star',
        '        const dx = game.star.x - ast.x, dy = game.star.y - ast.y;',
        '        const distSq = Math.max(dx * dx + dy * dy, 36);',
        '        const dist = Math.sqrt(distSq);',
        '        const gravityConst = GRAVITY_BASE * gravityScale;',
        '        const gravityAccel = gravityConst * game.star.mass / distSq;',
        '        ast.vx += (dx / dist) * gravityAccel * dt;',
        '        ast.vy += (dy / dist) * gravityAccel * dt;',
        '        ast.vx *= 0.9998; ast.vy *= 0.9998;',
        '        ast.x += ast.vx * dt; ast.y += ast.vy * dt;',
        '        ast.rotation += ast.rotationSpeed * dt;',
        '        wrapPosition(ast);',
        '        // Check collision with star',
        '        if (dist < game.star.radius + ast.radius * 0.6) { game.asteroids.splice(i, 1); continue; }',
        '        // Check collision with ships',
        '        for (const ship of game.ships) {',
        '          if (ship.respawnTimer > 0 || ship.lives <= 0 || ship.invulnerableTime > 0) continue;',
        '          const sdx = ast.x - ship.x, sdy = ast.y - ship.y;',
        "          if (Math.hypot(sdx, sdy) < ast.radius * 0.7 + ship.radius * 0.7) {",
        "            processDestruction(ship, null, 'asteroid collision');",
        '            ship.damage = 0; ship.damageParticles = [];',
        '            game.asteroids.splice(i, 1);',
        '            break;',
        '          }',
        '        }',
        '      }',
        '    }',
        '    // Check projectile collisions with asteroids',
        '    for (let pi = game.projectiles.length - 1; pi >= 0; pi--) {',
        '      const shot = game.projectiles[pi];',
        '      for (let ai = game.asteroids.length - 1; ai >= 0; ai--) {',
        '        const ast = game.asteroids[ai];',
        '        const dx = shot.x - ast.x, dy = shot.y - ast.y;',
        '        if (Math.hypot(dx, dy) < ast.radius * 0.8) {',
        '          audio.impact();',
        '          releaseShot(shot, pi);',
        '          splitAsteroid(ast, ai);',
        '          break;',
        '        }',
        '      }',
        '    }',
        '  }',
        '  function updateShips(dt, activePhase) {',
        '    for (const ship of game.ships) {',
        '      if (ship.lastExplosion) {',
        '        ship.lastExplosion.timer = Math.max(0, ship.lastExplosion.timer - dt);',
        '        if (ship.lastExplosion.timer === 0) ship.lastExplosion = null;',
        '      }',
        '      if (ship.respawnTimer > 0) {',
        '        ship.respawnTimer = Math.max(0, ship.respawnTimer - dt);',
        '        if (ship.respawnTimer === 0) respawnShip(ship);',
        '        continue;',
        '      }',
        '      if (ship.lives <= 0) continue;',
        '      ship.invulnerableTime = Math.max(0, ship.invulnerableTime - dt);',
        '      ship.hyperspaceCooldown = Math.max(0, ship.hyperspaceCooldown - dt);',
        '      ship.cooldown = Math.max(0, ship.cooldown - dt);',
        '      if (!activePhase) { ship.thrusting = false; continue; }',
        '      const intent = resolveShipIntent(ship, dt);',
        '      if (intent.left && !intent.right) ship.angle -= ship.turnRate * dt;',
        '      if (intent.right && !intent.left) ship.angle += ship.turnRate * dt;',
        '      ship.angle = normalizeAngle(ship.angle);',
        '      ship.thrusting = !!intent.thrust;',
        '      if (ship.thrusting) { ship.vx += Math.cos(ship.angle) * ship.thrustPower * dt; ship.vy += Math.sin(ship.angle) * ship.thrustPower * dt; }',
        '      if (ship.thrusting) { audio.thrust(ship.id); }',
        '      const dx = game.star.x - ship.x, dy = game.star.y - ship.y;',
        '      const distSq = Math.max(dx * dx + dy * dy, 36);',
        '      const dist = Math.sqrt(distSq);',
        '      const gravityConst = GRAVITY_BASE * gravityScale;',
        '      const gravityAccel = gravityConst * game.star.mass / distSq;',
        '      ship.vx += (dx / dist) * gravityAccel * dt;',
        '      ship.vy += (dy / dist) * gravityAccel * dt;',
        '      ship.vx *= 0.9993; ship.vy *= 0.9993;',
        '      const speedSq = ship.vx * ship.vx + ship.vy * ship.vy;',
        '      if (speedSq > SHIP_MAX_SPEED * SHIP_MAX_SPEED) {',
        '        const scale = SHIP_MAX_SPEED / Math.sqrt(speedSq);',
        '        ship.vx *= scale; ship.vy *= scale;',
        '      }',
        '      ship.x += ship.vx * dt; ship.y += ship.vy * dt;',
        '      wrapPosition(ship);',
        "      if (dist < game.star.radius + ship.radius * 0.55) { processDestruction(ship, null, 'the gravity well'); continue; }",
        '      if (intent.fire) fireShot(ship);',
        '      // Update damage particles',
        '      for (let pi = ship.damageParticles.length - 1; pi >= 0; pi--) {',
        '        const p = ship.damageParticles[pi];',
        '        p.life -= dt;',
        '        if (p.life <= 0) { ship.damageParticles.splice(pi, 1); continue; }',
        '        p.x += p.vx * dt; p.y += p.vy * dt;',
        '        p.vx *= 0.96; p.vy *= 0.96;',
        '      }',
        '      // Spawn sputter particles based on damage level',
        '      if (ship.damage >= 1) {',
        '        const sputterChance = ship.damage >= 2 ? 0.35 : 0.12;',
        '        if (Math.random() < sputterChance) spawnSputter(ship);',
        '      }',
        '    }',
        '    // Ship-to-ship collision check (destroys both ships)',
        '    if (activePhase && game.ships.length === 2) {',
        '      const s1 = game.ships[0], s2 = game.ships[1];',
        '      if (s1.respawnTimer <= 0 && s2.respawnTimer <= 0 && s1.lives > 0 && s2.lives > 0) {',
        '        const dx = s1.x - s2.x, dy = s1.y - s2.y;',
        '        const collisionDist = s1.radius + s2.radius;',
        '        if (Math.hypot(dx, dy) < collisionDist * 0.75) {',
        "          processDestruction(s1, null, 'ship collision');",
        "          processDestruction(s2, null, 'ship collision');",
        '          s1.damage = 0; s1.damageParticles = [];',
        '          s2.damage = 0; s2.damageParticles = [];',
        '        }',
        '      }',
        '    }',
        '  }',
        '  function update(dt) {',
        '    const t = dt * PHYSICS_SLOWDOWN;',
        '    if (game.flashMessage.timer > 0) {',
        '      game.flashMessage.timer = Math.max(0, game.flashMessage.timer - t);',
        "      if (game.flashMessage.timer === 0) game.flashMessage.text = '';",
        '    }',
        '    game.star.pulse = (game.star.pulse + t * 0.6) % (Math.PI * 2);',
        '    if (!game.running) return;',
        '    if (game.countdown > 0) game.countdown = Math.max(0, game.countdown - t);',
        '    if (game.nextRoundTimer > 0) {',
        '      game.nextRoundTimer = Math.max(0, game.nextRoundTimer - t);',
        '      if (game.nextRoundTimer === 0 && !game.victoryAchieved) resetRound();',
        '      return;',
        '    }',
        '    const activePhase = game.countdown <= 0;',
        '    updateShips(t, activePhase);',
        '    updateBackgroundShip(t, activePhase);',
        '    updateProjectiles(t, activePhase);',
        '    updateAsteroids(t, activePhase);',
        '    updateDebris(t);',
        '  }',
        '  function updateDebris(dt) {',
        '    for (let i = game.debris.length - 1; i >= 0; i--) {',
        '      const d = game.debris[i];',
        '      d.life -= dt;',
        '      if (d.life <= 0) { game.debris.splice(i, 1); continue; }',
        '      d.x += d.vx * dt;',
        '      d.y += d.vy * dt;',
        '      d.angle += d.spin * dt;',
        '      d.vx *= 0.985;',
        '      d.vy *= 0.985;',
        '      d.spin *= 0.98;',
        '    }',
        '  }',
        '',
        '  function drawStar() {',
        '    const { x, y, radius, pulse } = game.star;',
        '    const colors = currentPalette();',
        '    ctx.save(); ctx.translate(x, y); ctx.rotate(pulse * 0.6);',
        '    // Scintillation: beams pulse between bright and soft',
        '    const scint1 = 0.4 + 0.6 * (0.5 + 0.5 * Math.sin(pulse * 3.7));',
        '    const scint2 = 0.4 + 0.6 * (0.5 + 0.5 * Math.sin(pulse * 4.3 + 1.2));',
        '    // Main cross beams',
        "    ctx.strokeStyle = `rgba(155, 255, 155, ${scint1})`; ctx.lineWidth = 1.4; ctx.shadowColor = colors.star; ctx.shadowBlur = 12 * scint1;",
        '    ctx.beginPath(); ctx.moveTo(-radius, 0); ctx.lineTo(radius, 0); ctx.moveTo(0, -radius); ctx.lineTo(0, radius); ctx.stroke();',
        '    // Diagonal beams with offset scintillation',
        "    ctx.strokeStyle = `rgba(155,255,155,${scint2})`; ctx.shadowBlur = 12 * scint2;",
        '    ctx.beginPath(); const diag = radius * 0.68;',
        '    ctx.moveTo(-diag, -diag); ctx.lineTo(diag, diag);',
        '    ctx.moveTo(-diag, diag); ctx.lineTo(diag, -diag); ctx.stroke();',
        '    ctx.restore();',
        '  }',
        '  function drawBackgroundShip() {',
        '    const npc = game.backgroundShip;',
        '    if (!npc || !npc.active) return;',
        '    const color = npc.color || currentPalette().overlayRobot;',
        '    ctx.save();',
        '    ctx.translate(npc.x, npc.y);',
        '    ctx.rotate(npc.angle);',
        '    ctx.globalAlpha = 0.6;',
        '    ctx.strokeStyle = color;',
        '    ctx.lineWidth = 1.4;',
        '    ctx.shadowColor = color;',
        '    ctx.shadowBlur = 8;',
        '    const r = BACKGROUND_SHIP_RADIUS;',
        '    const saucerR = r * 0.95;',
        '    const domeR = r * 0.45;',
        '    ctx.beginPath();',
        '    ctx.ellipse(0, 0, saucerR, saucerR * 0.48, 0, 0, Math.PI * 2);',
        '    ctx.stroke();',
        '    ctx.beginPath();',
        '    ctx.ellipse(0, 0, saucerR * 0.9, saucerR * 0.32, 0, 0, Math.PI * 2);',
        '    ctx.stroke();',
        '    ctx.beginPath();',
        '    ctx.arc(0, -r * 0.1, domeR, Math.PI, 0);',
        '    ctx.stroke();',
        '    ctx.beginPath();',
        '    ctx.moveTo(-saucerR * 0.9, 0);',
        '    ctx.lineTo(-saucerR * 1.35, Math.sin(npc.waveTimer * 2) * 2);',
        '    ctx.stroke();',
        '    ctx.restore();',
        '  }',
        '  function drawProjectiles() {',
        '    game.projectiles.forEach((shot) => {',
        '      const heading = shot.heading !== undefined ? shot.heading : Math.atan2(shot.vy, shot.vx);',
        '      const len = 14;',
        '      const tailX = shot.x - Math.cos(heading) * len;',
        '      const tailY = shot.y - Math.sin(heading) * len;',
        '      ctx.save(); ctx.strokeStyle = shot.color; ctx.lineWidth = 1.3; ctx.shadowColor = shot.color; ctx.shadowBlur = 10;',
        '      ctx.beginPath(); ctx.moveTo(shot.x, shot.y); ctx.lineTo(tailX, tailY); ctx.stroke();',
        '      ctx.restore();',
        '    });',
        '  }',
        '  function drawAsteroids() {',
        '    game.asteroids.forEach((ast) => {',
        '      const firstVertex = ast && ast.vertices && ast.vertices[0];',
        '      if (!ast || typeof ast.x !== "number" || typeof ast.y !== "number" || !firstVertex || typeof firstVertex.x !== "number" || typeof firstVertex.y !== "number") return;',
        '      const colors = currentPalette();',
        "      ctx.save(); ctx.translate(ast.x, ast.y); ctx.rotate(ast.rotation);",
        '      ctx.strokeStyle = colors.asteroid; ctx.lineWidth = 1.6; ctx.shadowColor = colors.asteroid; ctx.shadowBlur = 6;',
        '      ctx.beginPath();',
        '      ctx.moveTo(firstVertex.x, firstVertex.y);',
        '      for (let i = 1; i < ast.vertices.length; i++) {',
        '        const vertex = ast.vertices[i];',
        '        if (!vertex || typeof vertex.x !== "number" || typeof vertex.y !== "number") continue;',
        '        ctx.lineTo(vertex.x, vertex.y);',
        '      }',
        '      ctx.closePath();',
        '      ctx.stroke(); ctx.restore();',
        '    });',
        '  }',
        '  function drawExplosion(explosion) {',
        '    const progress = explosion.timer / 0.45;',
        '    const scale = 1 - progress;',
        '    ctx.save(); ctx.strokeStyle = explosion.color; ctx.lineWidth = 1.8; ctx.shadowColor = explosion.color; ctx.shadowBlur = 16; ctx.globalAlpha = progress;',
        '    ctx.beginPath();',
        '    ctx.moveTo(explosion.x - 22 * scale, explosion.y); ctx.lineTo(explosion.x + 22 * scale, explosion.y);',
        '    ctx.moveTo(explosion.x, explosion.y - 22 * scale); ctx.lineTo(explosion.x, explosion.y + 22 * scale);',
        '    ctx.stroke(); ctx.restore();',
        '  }',
        '',
        '  function drawAsteroidsShip(r, damage) {',
        '    ctx.beginPath();',
        '    // Front tip',
        '    ctx.moveTo(r * 1.05, 0);',
        '    // Top-right side',
        '    if (damage < 1) {',
        '      ctx.lineTo(-r * 0.75, r * 0.6);',
        '    } else {',
        '      // Damage 1+: draw only half of top-right side',
        '      ctx.lineTo(r * 0.15, r * 0.3);',
        '      ctx.moveTo(-r * 0.75, r * 0.6);',
        '    }',
        '    // Back indent',
        '    if (damage < 2) {',
        '      ctx.lineTo(-r * 0.55, 0);',
        '    } else {',
        '      // Damage 2: lose half the back indent too',
        '      ctx.lineTo(-r * 0.65, r * 0.3);',
        '      ctx.moveTo(-r * 0.55, 0);',
        '    }',
        '    // Bottom-right side (always drawn)',
        '    ctx.lineTo(-r * 0.75, -r * 0.6);',
        '    ctx.lineTo(r * 1.05, 0);',
        '    ctx.stroke();',
        '  }',
        '  function drawAsteroidsFlame(r) {',
        '    ctx.beginPath();',
        '    ctx.moveTo(-r * 0.8, 0);',
        '    ctx.lineTo(-r * 1.45, r * 0.32);',
        '    ctx.lineTo(-r * 1.65, 0);',
        '    ctx.lineTo(-r * 1.45, -r * 0.32);',
        '    ctx.closePath();',
        '    ctx.stroke();',
        '  }',
        '  function drawEnterpriseShip(r, damage) {',
        '    const saucerR = r * 0.65;',
        '    const saucerCircleR = saucerR * 0.78;',
        '    const neckLen = r * 0.45;',
        '    const nacelleLen = r * 0.7;',
        '    const nacelleGap = r * 0.45;',
        '    ctx.beginPath();',
        '    ctx.arc(0, 0, saucerCircleR, 0, Math.PI * 2);',
        '    ctx.stroke();',
        '    ctx.beginPath();',
        '    ctx.moveTo(-saucerR * 0.6, 0);',
        '    ctx.lineTo(-saucerR * 0.6 - neckLen, 0);',
        '    ctx.stroke();',
        '    ctx.beginPath();',
        '    ctx.moveTo(-saucerR * 0.6 - neckLen, r * 0.26);',
        '    ctx.lineTo(-saucerR * 0.6 - neckLen, -r * 0.26);',
        '    ctx.stroke();',
        '    // Top nacelle - damage affects progressively',
        '    const nacelleStartX = -saucerR * 0.6 - neckLen;',
        '    const nacelleEndX = nacelleStartX - nacelleLen;',
        '    if (damage < 1) {',
        '      // Full top nacelle',
        '      ctx.beginPath();',
        '      ctx.moveTo(nacelleStartX, nacelleGap);',
        '      ctx.lineTo(nacelleEndX, nacelleGap);',
        '      ctx.stroke();',
        '      ctx.beginPath();',
        '      ctx.arc(nacelleEndX, nacelleGap, r * 0.18, -Math.PI / 2, Math.PI / 2);',
        '      ctx.stroke();',
        '    } else if (damage < 2) {',
        '      // Half top nacelle (front half destroyed)',
        '      ctx.beginPath();',
        '      ctx.moveTo(nacelleStartX, nacelleGap);',
        '      ctx.lineTo(nacelleStartX - nacelleLen * 0.5, nacelleGap);',
        '      ctx.stroke();',
        '    }',
        '    // Bottom nacelle - always fully drawn (undamaged)',
        '    ctx.beginPath();',
        '    ctx.moveTo(nacelleStartX, -nacelleGap);',
        '    ctx.lineTo(nacelleEndX, -nacelleGap);',
        '    ctx.stroke();',
        '    ctx.beginPath();',
        '    ctx.arc(nacelleEndX, -nacelleGap, r * 0.18, Math.PI / 2, -Math.PI / 2, true);',
        '    ctx.stroke();',
        '  }',
        '  function drawEnterpriseFlame(r, damage) {',
        '    const saucerR = r * 0.65;',
        '    const neckLen = r * 0.45;',
        '    const nacelleLen = r * 0.7;',
        '    const nacelleGap = r * 0.45;',
        '    const flameLen = r * 0.55;',
        '    const baseX = -saucerR * 0.6 - neckLen - nacelleLen;',
        '    // Top nacelle flame - only if no damage (nacelle fully intact)',
        '    if ((damage || 0) < 1) {',
        '      ctx.beginPath();',
        '      ctx.moveTo(baseX, nacelleGap);',
        '      ctx.lineTo(baseX - flameLen, nacelleGap + r * 0.18);',
        '      ctx.lineTo(baseX - flameLen * 1.1, nacelleGap);',
        '      ctx.lineTo(baseX - flameLen, nacelleGap - r * 0.18);',
        '      ctx.closePath();',
        '      ctx.stroke();',
        '    }',
        '    // Bottom nacelle flame - always available (undamaged nacelle)',
        '    ctx.beginPath();',
        '    ctx.moveTo(baseX, -nacelleGap);',
        '    ctx.lineTo(baseX - flameLen, -nacelleGap + r * 0.18);',
        '    ctx.lineTo(baseX - flameLen * 1.1, -nacelleGap);',
        '    ctx.lineTo(baseX - flameLen, -nacelleGap - r * 0.18);',
        '    ctx.closePath();',
        '    ctx.stroke();',
        '  }',
        '',
        '  function drawDebris() {',
        '    for (const d of game.debris) {',
        '      if (d.segments.length < 2) continue;',
        '      ctx.save();',
        '      ctx.translate(d.x, d.y);',
        '      ctx.rotate(d.angle);',
        '      // Calculate glow intensity based on life (brighter at start, fading)',
        '      const lifeRatio = d.life / d.maxLife;',
        '      const glowIntensity = Math.pow(lifeRatio, 0.5);',
        '      const alpha = Math.min(1, lifeRatio * 1.5);',
        '      // Parse base color and make it brighter/whiter',
        '      const baseColor = d.color;',
        '      // Create plasma glow effect - white core fading to ship color',
        '      const whiteMix = glowIntensity * 0.7;',
        '      ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * whiteMix})`;',
        '      ctx.lineWidth = 3 + glowIntensity * 2;',
        '      ctx.shadowColor = baseColor;',
        '      ctx.shadowBlur = 15 + glowIntensity * 20;',
        '      // Draw the debris shape',
        '      ctx.beginPath();',
        '      ctx.moveTo(d.segments[0][0], d.segments[0][1]);',
        '      for (let i = 1; i < d.segments.length; i++) {',
        '        ctx.lineTo(d.segments[i][0], d.segments[i][1]);',
        '      }',
        '      ctx.stroke();',
        '      // Second pass with ship color for depth',
        '      ctx.strokeStyle = baseColor;',
        '      ctx.globalAlpha = alpha * (1 - whiteMix * 0.5);',
        '      ctx.lineWidth = 1.8;',
        '      ctx.shadowBlur = 8;',
        '      ctx.beginPath();',
        '      ctx.moveTo(d.segments[0][0], d.segments[0][1]);',
        '      for (let i = 1; i < d.segments.length; i++) {',
        '        ctx.lineTo(d.segments[i][0], d.segments[i][1]);',
        '      }',
        '      ctx.stroke();',
        '      ctx.restore();',
        '    }',
        '  }',
        '  function drawDamageParticles(ship) {',
        '    if (!ship.damageParticles || ship.damageParticles.length === 0) return;',
        '    ctx.save();',
        '    const colors = currentPalette();',
        '    for (const p of ship.damageParticles) {',
        '      const alpha = Math.min(1, p.life * 2);',
        '      if (retroColorsEnabled) {',
        '        if (p.isSpark) {',
        '          ctx.shadowColor = colors.flash; ctx.shadowBlur = 8;',
        "          ctx.fillStyle = `rgba(120, 255, 140, ${alpha})`;",
        '        } else {',
        '          ctx.shadowBlur = 0;',
        "          ctx.fillStyle = `rgba(60, 180, 80, ${alpha * 0.8})`;",
        '        }',
        '      } else {',
        '        if (p.isSpark) {',
        "          ctx.shadowColor = '#ffff80'; ctx.shadowBlur = 8;",
        "          ctx.fillStyle = `rgba(255, 255, ${Math.floor(180 + Math.random() * 75)}, ${alpha})`;",
        '        } else {',
        '          ctx.shadowBlur = 0;',
        "          ctx.fillStyle = `rgba(255, ${Math.floor(100 + Math.random() * 80)}, 0, ${alpha})`;",
        '        }',
        '      }',
        '      ctx.beginPath();',
        '      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);',
        '      ctx.fill();',
        '    }',
        '    ctx.restore();',
        '  }',
        '  function drawShips() {',
        '    for (const ship of game.ships) {',
        '      // Draw damage smoke/sparks first (behind ship)',
        '      drawDamageParticles(ship);',
        '      if (ship.respawnTimer <= 0 && ship.lives > 0) {',
        '        ctx.save();',
        '        ctx.translate(ship.x, ship.y);',
        '        ctx.rotate(ship.angle);',
        '        ctx.strokeStyle = ship.color;',
        '        ctx.lineWidth = 1.8;',
        '        ctx.shadowColor = ship.color;',
        '        ctx.shadowBlur = 12;',
        '        if (ship.invulnerableTime > 0) {',
        '          ctx.globalAlpha = 0.55 + 0.35 * Math.sin(performance.now() * 0.01);',
        "          ctx.setLineDash([6, 6]);",
        "        }",
        "        const r = ship.id === 'robot' ? ship.radius * ROBOT_SHIP_SCALE : ship.radius;",
        "        if (ship.id === 'alpha') {",
        "          drawAsteroidsShip(r, ship.damage);",
        "        } else {",
        "          drawEnterpriseShip(r, ship.damage);",
        "        }",
        "        if (ship.thrusting && game.countdown <= 0) {",
        "          if (ship.id === 'alpha') drawAsteroidsFlame(r);",
        "          else drawEnterpriseFlame(r, ship.damage);",
        "        }",
        "        ctx.restore();",
        "      }",
        "      if (ship.lastExplosion && ship.lastExplosion.timer > 0) drawExplosion(ship.lastExplosion);",
        "    }",
        "  }",
        "  function drawBorder() {", 
        "    const edge = retroColorsEnabled ? 'rgba(80, 255, 120, 0.18)' : 'rgba(0, 255, 255, 0.18)';",
        "    ctx.save(); ctx.strokeStyle = edge; ctx.lineWidth = 1; ctx.strokeRect(0.5, 0.5, canvas.width - 1, canvas.height - 1); ctx.restore();",
        "  }",
        "  function drawOverlayText() {",
        "    const alpha = game.ships[0], robot = game.ships[1];",
        '    const colors = currentPalette();',
        "    ctx.save(); ctx.shadowBlur = 0; ctx.font = `600 ${Math.max(16, canvas.width * 0.016)}px \"Courier New\", monospace`; ctx.textBaseline = 'top';",
        "    ctx.fillStyle = colors.overlayAlpha; ctx.textAlign = 'left'; ctx.fillText(`Alpha: ${alpha ? alpha.score : 0}  ∑ ${alpha ? alpha.lives : 0}`, 20, 18);",
        "    ctx.fillStyle = colors.overlayRobot; ctx.textAlign = 'right'; ctx.fillText(`Robo: ${robot ? robot.score : 0}  ∑ ${robot ? robot.lives : 0}`, canvas.width - 20, 18);",
        "    ctx.restore();",
        "    if (game.countdown > 0) {",
        "      const display = game.countdown > 0.4 ? 'Stand by' : 'Engage!';",
        "      ctx.save(); ctx.fillStyle = colors.overlayPrimary; ctx.shadowColor = colors.overlayPrimary; ctx.shadowBlur = 18;",
        "      ctx.font = `700 ${Math.max(32, canvas.width * 0.07)}px \"Courier New\", monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';",
        "      ctx.fillText(display, canvas.width / 2, canvas.height / 2); ctx.restore();",
        "    } else if (game.nextRoundTimer > 0) {",
        "      ctx.save(); ctx.fillStyle = colors.overlayPrimary; ctx.shadowColor = colors.overlayPrimary; ctx.shadowBlur = 18;",
        "      ctx.font = `700 ${Math.max(26, canvas.width * 0.055)}px \"Courier New\", monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';",
        "      ctx.fillText(`Recalibrating round ${game.round + 1}`, canvas.width / 2, canvas.height / 2); ctx.restore();",
        "    }",
        "    if (game.flashMessage.text && game.flashMessage.timer > 0) {",
        "      ctx.save(); ctx.fillStyle = colors.flash; ctx.shadowColor = colors.flash; ctx.shadowBlur = 12;",
        "      ctx.font = `500 ${Math.max(14, canvas.width * 0.018)}px \"Courier New\", monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';",
        "      ctx.fillText(game.flashMessage.text, canvas.width / 2, canvas.height - 28); ctx.restore();",
        "    }",
        "  }",
        "  function render() {",
        "    if (canvas.width === 0 || canvas.height === 0) return;",
        "    ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);",
        "    drawStar(); drawBackgroundShip(); drawAsteroids(); drawProjectiles(); drawDebris(); drawShips(); drawBorder(); drawOverlayText();",
        "  }",
        "  function gameLoop(timestamp) {",
        "    if (!game.lastTime) game.lastTime = timestamp;",
        "    const dt = Math.min((timestamp - game.lastTime) / 1000, 0.08);",
        "    game.lastTime = timestamp; update(dt); render(); requestAnimationFrame(gameLoop);",
        "  }",
        "",
        "  function handleKeyDown(event) {",
        "    const { code } = event;",
        "    if (code === 'Escape') {",
        "      if (game.running) {",
        "        stopGame({ title: 'Simulation aborted', message: 'Mission aborted via Escape. Engage again to resume battle.' });",
        "      }",
        "      event.preventDefault();",
        "      return;",
        "    }",
        "    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(code)) event.preventDefault();",
        "    if (!game.keys[code]) {",
        "      game.keys[code] = true;",
        '      if (!event.repeat && game.running) {',
        '        game.ships.forEach((ship) => { if (ship.controls.hyperspace.includes(code)) attemptHyperspace(ship); });',
        '      }',
        '    } else { game.keys[code] = true; }',
        '  }',
        '  function handleKeyUp(event) { game.keys[event.code] = false; }',
        '',
        '  function canvasPosFromEvent(e) {',
        '    const rect = canvas.getBoundingClientRect();',
        '    const dpr = window.devicePixelRatio || 1;',
        '    return { x: (e.clientX - rect.left) * dpr, y: (e.clientY - rect.top) * dpr };',
        '  }',
        '  function handlePointerDown(e) {',
        '    if (!game.running) startGame();',
        '    if (pointerState.pointerId !== null && pointerState.pointerId !== e.pointerId) return;',
        '    pointerState.pointerId = e.pointerId;',
        '    pointerState.pointerDown = true;',
        '    pointerState.downTime = performance.now();',
        "    const now = performance.now();",
        "    if (now - pointerState.lastTap < 320) {",
        "      const alpha = game.ships.find((s) => s.id === 'alpha');",
        "      if (alpha) attemptHyperspace(alpha);",
        "    }",
        "    pointerState.lastTap = now;",
        "    const pos = canvasPosFromEvent(e);",
        "    pointerState.aimX = pos.x; pointerState.aimY = pos.y;",
        "    pointerState.thrust = e.button === 2;",
        "    pointerState.fireQueued = false;",
        "    if (e.pointerType === 'touch') e.preventDefault();",
        "  }",
        "  function handlePointerMove(e) {",
        "    if (pointerState.pointerId !== null && pointerState.pointerId !== e.pointerId) return;",
        "    const pos = canvasPosFromEvent(e);",
        "    pointerState.aimX = pos.x; pointerState.aimY = pos.y;",
        "    if (pointerState.pointerDown) {",
        "      const held = performance.now() - pointerState.downTime;",
        "      if (held > 140 && e.button !== 2) pointerState.thrust = true;",
        "    }",
        "  }",
        "  function handlePointerUp(e) {",
        "    if (pointerState.pointerId !== null && pointerState.pointerId !== e.pointerId) return;",
        "    const elapsed = performance.now() - pointerState.downTime;",
        "    if (elapsed < 180) pointerState.fireQueued = true;",
        "    pointerState.pointerDown = false;",
        "    pointerState.thrust = false;",
        "    pointerState.pointerId = null;",
        "  }",
        "  function handlePointerCancel() {",
        "    pointerState.pointerDown = false;",
        "    pointerState.thrust = false;",
        "    pointerState.pointerId = null;",
        "  }",
        "",
        "  function updateGravityFromSlider(value) {",
        "    const sliderVal = clamp(value / 100, 0, 1);",
        "    gravityScale = sliderVal * GRAVITY_MAX_SCALE;",
        "    if (gravityLabel) gravityLabel.textContent = `${Math.round(value)}%`;",
        "  }",
        "",
        "  targetScoreEl.textContent = game.settings.winningScore;",
        "  livesPerRoundEl.textContent = game.settings.livesPerRound;",
        "  updateGravityFromSlider(Number(gravityRange.value || 100));",
        "",
        "  createShips();",
        "  resizeCanvas();",
        "  initializeGameState();",
        "  setOverlay({ visible: true, title: 'Space War Game', body: 'Vector display calibrated. Engage the simulation to enter full-window combat.' });",
        '  applyPaletteToEntities();',
        "",
        "  startButton.addEventListener('click', startGame);",
        "  resetButton.addEventListener('click', () => {",
        "    stopGame({ title: 'Simulation reset to briefing', message: 'Mission parameters cleared. Engage simulation to re-enter the vector battlefield.', resetScores: true });",
        "  });",
        '  if (retroColorsToggle) {',
        '    retroColorsToggle.checked = retroColorsEnabled;',
        '    retroColorsToggle.addEventListener("change", () => {',
        '      retroColorsEnabled = !!retroColorsToggle.checked;',
        '      applyPaletteToEntities();',
        '    });',
        '  }',
        "  if (isMobileDevice()) attachMobileControls();",
        "  gravityRange.addEventListener('input', (e) => updateGravityFromSlider(e.target.value));",
        "  window.addEventListener('resize', () => {",
        "    resizeCanvas();",
        "    if (game.running) { setSpawnPositions(true); } else { refreshHud(); }",
        "  });",
        "  new ResizeObserver(() => { resizeCanvas(); }).observe(stage);",
        "  stage.addEventListener('pointerdown', (e) => { if (!game.running) { e.preventDefault(); startGame(); } });",
        "  canvas.addEventListener('pointerdown', handlePointerDown);",
        "  canvas.addEventListener('pointermove', handlePointerMove);",
        "  canvas.addEventListener('pointerup', handlePointerUp);",
        "  canvas.addEventListener('pointerleave', handlePointerCancel);",
        "  canvas.addEventListener('pointercancel', handlePointerCancel);",
        "  canvas.addEventListener('contextmenu', (e) => e.preventDefault(), { passive: false });",
        "  window.addEventListener('keydown', handleKeyDown);",
        "  window.addEventListener('keyup', handleKeyUp);",
        "",
        "  gameLoop(performance.now());",
        "})();",
        '</script>',
        '</body>',
    ].join('\n')
}