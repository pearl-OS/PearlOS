export interface StorageLibraryOptions {
  tenantId?: string;
  assistantName?: string;
}

const buildNiaAPIClassLines = (resolvedTenantId: string, resolvedAssistantName: string): string[] => {
  return [
    'class NiaAPI {',
    '  constructor(tenantId, assistantName) {',
    `    this.tenantId = tenantId || "${resolvedTenantId}";`,
    `    this.assistantName = assistantName || "${resolvedAssistantName}";`,
    "    this.baseURL = '/api/applet-api';",
    '  }',
    '',
    '  async listData(query = {}) {',
    '    const params = new URLSearchParams({',
    "      operation: 'list',",
    '      tenantId: this.tenantId,',
    '      assistantName: this.assistantName',
    '    });',
    '    if (Object.keys(query).length) params.append("query", JSON.stringify(query));',
    '    const response = await fetch(this.baseURL + "?" + params);',
    "    if (!response.ok) throw new Error('Failed to list data');",
    '    const result = await response.json();',
    '    return result.items || [];',
    '  }',
    '',
    '  async getData(dataId) {',
    '    const params = new URLSearchParams({',
    "      operation: 'get',",
    '      tenantId: this.tenantId,',
    '      dataId: dataId,',
    '      assistantName: this.assistantName',
    '    });',
    '    const response = await fetch(this.baseURL + "?" + params);',
    "    if (!response.ok) throw new Error('Failed to get data');",
    '    const result = await response.json();',
    '    return result.item;',
    '  }',
    '',
    '  async saveData(data) {',
    '    const params = new URLSearchParams({',
    "      operation: 'create',",
    '      tenantId: this.tenantId,',
    '      assistantName: this.assistantName',
    '    });',
    '    const response = await fetch(this.baseURL + "?" + params, {',
    "      method: 'POST',",
    "      headers: { 'Content-Type': 'application/json' },",
    '      body: JSON.stringify({ data })',
    '    });',
    "    if (!response.ok) throw new Error('Failed to save data');",
    '    const result = await response.json();',
    '    return result.item;',
    '  }',
    '',
    '  async updateData(dataId, data) {',
    '    const params = new URLSearchParams({',
    "      operation: 'update',",
    '      tenantId: this.tenantId,',
    '      dataId: dataId,',
    '      assistantName: this.assistantName',
    '    });',
    '    const response = await fetch(this.baseURL + "?" + params, {',
    "      method: 'PUT',",
    "      headers: { 'Content-Type': 'application/json' },",
    '      body: JSON.stringify({ data })',
    '    });',
    "    if (!response.ok) throw new Error('Failed to update data');",
    '    const result = await response.json();',
    '    return result.item;',
    '  }',
    '',
    '  async deleteData(dataId) {',
    '    const params = new URLSearchParams({',
    "      operation: 'delete',",
    '      tenantId: this.tenantId,',
    '      dataId: dataId,',
    '      assistantName: this.assistantName',
    '    });',
    '    const response = await fetch(this.baseURL + "?" + params, { method: "DELETE" });',
    "    if (!response.ok) throw new Error('Failed to delete data');",
    '    return await response.json();',
    '  }',
    '}',
  ];
};

export function buildStorageBootstrapSnippet(options: StorageLibraryOptions = {}): string {
  const resolvedTenantId = options.tenantId || 'TENANT_ID_HERE';
  const resolvedAssistantName = options.assistantName || 'ASSISTANT_NAME_HERE';
  const classLines = buildNiaAPIClassLines(resolvedTenantId, resolvedAssistantName);

  return [
    '<script>',
    '  // NiaAPI helper (embedded for persistence). Attaches to window.api for compatibility.',
    '  (function initNiaAPI() {',
    '    if (typeof window !== "undefined" && window.api && window.api.listData && window.api.saveData && window.api.updateData) {',
    '      return window.api;',
    '    }',
    ...classLines.map(line => '  ' + line),
    '    const api = new NiaAPI();',
    '    const applyConfig = (cfg) => {',
    '      if (!cfg) return;',
    '      if (cfg.tenantId) api.tenantId = cfg.tenantId;',
    '      if (cfg.assistantName) api.assistantName = cfg.assistantName;',
    '    };',
    '    if (typeof window !== "undefined") {',
    '      try {',
    '        const cfg = typeof window.getAppletConfig === "function" ? window.getAppletConfig() : null;',
    '        applyConfig(cfg);',
    '      } catch (err) {',
    '        console.warn("⚠️ Unable to read applet config during NiaAPI init", err);',
    '      }',
    '      window.addEventListener("appletConfigReady", (event) => {',
    '        applyConfig(event?.detail);',
    '      });',
    '      window.api = api;',
    '    }',
    '    return api;',
    '  })();',
    '</script>'
  ].join('\n');
}

/**
 * Returns the raw storage helper code so we can reuse it both in prompts and in tests.
 */
export function buildStorageLibraryCode(options: StorageLibraryOptions = {}): string {
  const resolvedTenantId = options.tenantId || 'TENANT_ID_HERE';
  const resolvedAssistantName = options.assistantName || 'ASSISTANT_NAME_HERE';
  const classLines = buildNiaAPIClassLines(resolvedTenantId, resolvedAssistantName);

  return [
    ...classLines,
    '',
    '// Initialize API (tenant/assistant IDs will be injected at runtime)',
    'const api = new NiaAPI();',
    'const __applyNiaConfig = (cfg) => {',
    '  if (!cfg) return;',
    '  if (cfg.tenantId) api.tenantId = cfg.tenantId;',
    '  if (cfg.assistantName) api.assistantName = cfg.assistantName;',
    '};',
    'if (typeof window !== "undefined") {',
    '  try {',
    '    const cfg = typeof window.getAppletConfig === "function" ? window.getAppletConfig() : null;',
    '    __applyNiaConfig(cfg);',
    '  } catch (err) {',
    '    console.warn("⚠️ Unable to read applet config during NiaAPI init", err);',
    '  }',
    '  window.addEventListener("appletConfigReady", (event) => {',
    '    __applyNiaConfig(event?.detail);',
    '  });',
    '  window.api = api;',
    '}'
  ].join('\n');
}

// Builds the storage appendix used by the creation engine so persistence guidance
// is reusable and scoped per-tenant/assistant.
export function buildStorageLibraryAppendix(options: StorageLibraryOptions = {}): string {
  const storageHelper = buildStorageLibraryCode(options);
  const storageBootstrap = buildStorageBootstrapSnippet(options);

  return [
    'STORAGE LIBRARY APPENDIX (Applet API is core — always use for persistent game state)',
    '',
    'WHEN TO USE THE API (fun-first):',
    '- Save runs/levels, player inventories, power-ups, cosmetics, quests.',
    '- Turn-based or asynchronous play: store turns, match state, seeds, maps, puzzles.',
    '- High scores, streaks, leaderboards, badges, unlocks, achievements.',
    '- Collaborative or viral experiences: shared boards, wish trees, remix chains.',
    '- Any experience that should survive reloads or be resumed/shared later.',
    '',
    'WHEN NOT TO USE:',
    '- One-turn throwaway toys where resetting is expected.',
    '- Pure calculators/converters that can stay in local state.',
    '',
    'NiaAPI HELPER (canonical persistence, scoped per tenant/assistant — prefer this over localStorage):',
    '```javascript',
    storageHelper,
    '```',
    '',
    'INLINE BOOTSTRAP (drop near the top of the HTML to ensure window.api exists):',
    '```html',
    storageBootstrap,
    '```',
    '',
    'DATA ISOLATION: Each applet automatically gets isolated storage; no data mixing across applets.',
    'CORE EXPECTATION: Treat this storage library as built-in; attach it whenever persistence makes the experience better.',
    '',
    'USAGE EXAMPLE (todos):',
    '```javascript',
    `async function loadTodos() {`,
    `  const items = await api.listData();`,
    `  items.forEach(item => addTodoToDOM(item._id, item.data.text, item.data.completed));`,
    `}`,
    ``,
    `async function addTodo() {`,
    `  const text = document.getElementById('todoInput').value.trim();`,
    `  if (!text) return;`,
    `  const item = await api.saveData({ text, completed: false, createdAt: new Date().toISOString() });`,
    `  addTodoToDOM(item._id, item.data.text, item.data.completed);`,
    `  document.getElementById('todoInput').value = '';`,
    `}`,
    ``,
    `async function toggleTodo(id) {`,
    `  const item = await api.getData(id);`,
    `  await api.updateData(id, { ...item.data, completed: !item.data.completed });`,
    `  updateTodoDOM(id, !item.data.completed);`,
    `}`,
    ``,
    `async function deleteTodo(id) {`,
    `  await api.deleteData(id);`,
    `  removeTodoFromDOM(id);`,
    `}`,
    '```',
    '',
    'API NOTES:',
    '- Each saved item gets an `_id`; use it for updates/deletes.',
    "- Store payload in the `data` field; handle errors with try/catch and show user feedback.",
    '- Show loading states during API calls.',
    '',
    'FORM VALIDATION (only if you expose inputs; arcade flows can skip UI text):',
    '- Show actionable errors with examples; use HTML5 types/patterns.',
    '- Phone: placeholder "(555) 123-4567", pattern `[0-9 ()-]+`.',
    '- Date: type="date", title "Format: YYYY-MM-DD".',
    '- Email: type="email", title "Format: user@example.com".',
    '- Credit card: pattern `[0-9\\s]+`, maxlength 19, title "Format: 1234 5678 9012 3456".',
    '- Postal code: pattern `[0-9\\-]+`, title "Format: 12345 or 12345-6789".',
    '- Provide real-time validation feedback (colors/icons) via showError/clearError helpers.',
    'Validation helper skeleton:',
    '```javascript',
    'function validateInput(input, format, isValid) {',
    "  if (!isValid) {", 
    "    showError(input, 'Please use format: ' + format);",
    '  } else {',
    '    clearError(input);',
    '  }',
    '}',
    '',
    'function showError(input, message) {',
    '  const errorDiv = input.parentNode.querySelector(".error-message");',
    '  if (errorDiv) {',
    '    errorDiv.textContent = message;',
    '    errorDiv.style.display = "block";',
    '  }',
    "  input.style.borderColor = '#dc3545';",
    '}',
    '',
    'function clearError(input) {',
    '  const errorDiv = input.parentNode.querySelector(".error-message");',
    '  if (errorDiv) {',
    '    errorDiv.style.display = "none";',
    '  }',
    "  input.style.borderColor = '#28a745';",
    '}',
    '```',
    '',
    'BUTTON + INTERACTION REQUIREMENTS:',
    '- Every button/action must do what its label implies (Start, Add, Save, Reset, Submit, etc.).',
    '- Bind handlers via onclick or addEventListener; keep functions global (window.func = ...).',
    '- Use delegation for dynamic buttons; always show some feedback for actions.',
    '',
    'MANDATORY INITIALIZATION:',
    '- Define functions in global scope and wire DOMContentLoaded for startup initialization.',
    '',
    'NO HEADINGS/TITLES IN OUTPUT: start directly with functional UI elements; avoid content-type badges.',
  ].join('\n');
}
