# JMeter Load Testing Setup for NIA Universal

This directory contains a complete JMeter-based load testing solution for NIA Universal, with a focus on testing dynamic content operations through the Prism client.

## Overview

This load testing solution:

1. Creates a REST API proxy that exposes Prism functionality via Express
2. Sets up a test tenant and dynamic content type
3. Runs JMeter tests that perform complete CRUD lifecycles per thread
4. Generates detailed performance reports
5. Cleans up all test data after completion

## Prerequisites

1. Install JMeter (5.5 or later recommended)

   ```bash
   # On macOS with Homebrew
   brew install jmeter
   
   # Or download from https://jmeter.apache.org/download_jmeter.cgi
   ```

2. Node.js 20+ and npm 10+ (already required for NIA Universal)

3. Running Mesh app instance
   
   The load tests require a running Mesh app instance to function properly, as Prism connects to the Mesh app for its operations. Start the Mesh app with:

   ```bash
   npm run dev -w apps/mesh
   ```

   By default, the tests expect the Mesh app to be running at `http://localhost:2000/graphql`. You can customize this by setting the MESH_ENDPOINT environment variable:

   ```bash
   MESH_ENDPOINT=https://aws.endpoint.hosting.nia.graphql npm run test:load
   ```

## Quick Start

Run the complete load test with default settings:

```bash
npm run test:load
```

Or choose a preconfigured test profile:

```bash
# Light load test (5 users, 1 minute)
npm run test:load:light

# Medium load test (10 users, 2 minutes)
npm run test:load:medium

# Heavy load test (30 users, 5 minutes)
npm run test:load:heavy
```

## Advanced Configuration

For advanced configuration, you can run the script directly with custom parameters:

```bash
cd tests/load-tests
./run-complete-test.sh [NUM_THREADS] [DURATION] [RAMP_UP] [LOOP_COUNT] [LOOP_CONTINUE_FOREVER]
```

Example:

```bash
./run-complete-test.sh 15 180 20 1000 false
```

## JMeter Test Plans

The main JMeter test plan is:

1. **load-test-unified.jmx**: Complete CRUD lifecycle per thread
   - Each thread creates its own records with unique identifiers
   - Each thread performs the entire lifecycle of create, query, update, and delete
   - Uses proper header management and proper JSON extraction
   - Prevents cross-thread access issues by using thread-specific record creation and management

## Test Components

The load testing solution consists of several components:

1. **API Proxy Server**:  
   - Creates a lightweight Express server that exposes Prism functionality through REST endpoints
   - Handles tenant ID from either headers or query parameters
   - Provides detailed logging of requests and responses
   - Returns records with predictable IDs for proper CRUD chaining

2. **Setup Scripts**:
   - `setup-api-server.sh`: Creates the API proxy
   - `setup-jmeter-test.ts`: Creates test tenant and content type
   - `start-api-server.sh`: Starts the API server (_generated by setup-api-server.sh_)

3. **JMeter Execution**:
   - `run-unified-test.sh`: Runs JMeter with configured parameters
   - Creates unified CRUD lifecycle workflow
   - Generates results in JTL format
   - Creates HTML reports

4. **Cleanup Scripts**:
   - `cleanup-jmeter-test.ts`: Removes all test data and content type definition

## Results and Reports

After running a test, you'll find:

1. JMeter results (.jtl files) in the `results` directory
2. HTML reports in directories named `report-unified-TIMESTAMP`
3. Log files in the `temp` directory, including `api.log` with detailed API server logs

## Test Architecture

The unified test architecture ensures:

1. **Thread Isolation**: Each thread manages its own records with unique identifiers
2. **Complete Lifecycle**: Each thread performs the entire CRUD process
3. **Proper Header Management**: Content-Type and tenant ID headers at thread group level
4. **Reliable ID Extraction**: JSON extraction with multiple paths for resilience
5. **Synchronized Operations**: Create → Query → Update → Delete in sequence

## Customizing Tests

To customize the test plans:

1. Open JMeter: `jmeter`
2. Open `load-test-unified.jmx`
3. Modify thread groups, samplers, or test logic
4. Save your changes
5. Run using the scripts provided

Key areas to customize:

- Thread count, ramp-up period, and loop count
- Request data structure in samplers
- JSON extractors for ID handling
- Transaction controllers for proper timing

## Troubleshooting

Common issues:

1. **API server won't start**: Check for port conflicts on 3099, or modify the port in `start-api-server.sh`
2. **JMeter not found**: Ensure JMeter is installed and in your PATH
3. **JSON Extraction failures**: If "NOT_FOUND" errors occur, check the API server logs to see the actual response format
4. **Missing tenant ID**: Ensure the tenant ID is being properly passed in headers or query parameters
5. **Permission denied**: Ensure all .sh files are executable with `chmod +x *.sh`
6. **Connection errors**: Verify that both the API server and Mesh app are running properly

## Further Optimizations

Potential areas for future enhancement:

1. Add more realistic data patterns and variations
2. Implement parameterized test data from external CSV files
3. Add response assertions for data validation
4. Integrate with CI/CD pipelines for automated performance testing
5. Create specialized test plans for specific load patterns
